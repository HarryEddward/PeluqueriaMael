#!/usr/bin/env python

import time
import numpy as np
import pycuda.driver as cuda
from pycuda.compiler import SourceModule
import pycuda.autoinit

class KeyExpansionTest:
    def __init__(self):
        self.getSourceModule()

        self.sbox = np.array([
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    	    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    	    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    	    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    	    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    	    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    	    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    	    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    	    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    	    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    	    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    	    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    	    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    	    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    	    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    	    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
        ], dtype=np.byte)

        self.rcon = np.array([
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    	    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    	    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    	    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    	    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    	    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
        	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
        	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
        	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
        	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
        	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
        	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
        	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
        	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
        	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
        ], dtype=np.byte)

    def getSourceModule(self):
        file = open("../kernels/KeyExpansion.cuh", "r")
        kernelwrapper = file.read()
        file.close()
        enable_test = """
        #define TEST_KEYEXPANSION
        """

        self.module = SourceModule(enable_test + kernelwrapper)


    def keyexpansion_gpu(self, cipherkey, nr_rounds):
        # Event objects to mark the start and end points
        start = cuda.Event()
        end = cuda.Event()

        # Start recording execution time
        start.record()

        # Device memory allocation for input and output arrays
        i_cipherkey_gpu = cuda.mem_alloc_like(cipherkey)
        o_expandedkey_gpu = cuda.mem_alloc(16 * (nr_rounds + 1) * cipherkey.dtype.itemsize)
        i_rcon_gpu = self.module.get_global('rcon')[0]
        i_sbox_gpu = self.module.get_global('sbox')[0]

        # Copy data from host to device
        cuda.memcpy_htod(i_cipherkey_gpu, cipherkey)
        cuda.memcpy_htod(i_rcon_gpu, self.rcon)
        cuda.memcpy_htod(i_sbox_gpu, self.sbox)

        # Call the kernel function from the compiled module
        prg = self.module.get_function("KeyExpansionTest")

        # Calculate block size and grid size
        blockDim = (1, 1, 1)

        # Call the kernel loaded to the device
        prg(i_cipherkey_gpu, o_expandedkey_gpu, block=blockDim)

        # Copy result from device to the host
        res = np.empty(16 * (nr_rounds + 1), cipherkey.dtype)
        cuda.memcpy_dtoh(res, o_expandedkey_gpu)

        # Record execution time (including memory transfers)
        end.record()
        end.synchronize()

        # return a tuple of output of sine computation and time taken to execute the operation (in ms).
        return res, start.time_till(end) * 10 ** (-3)

    def keyexpansion_cpu(self, cipherkey, nr_rounds):
        start = time.time()

        expandedkey = np.empty(16 * (nr_rounds + 1), cipherkey.dtype)

        # First part of the expanded key is equal to the Cipher key.
        expandedkey[:16] = cipherkey

        # Obtain the following parts of the ExpandedKey, creating a word (4 bytes)
        # during each iteration
        i = 16

        while i < 16 * (nr_rounds + 1):
            # Store the current last word of the ExpandedKey
            temp = expandedkey[i - 4 : i].copy()

            # If the current word is a multiple of the key length, then apply
            # a transformation
            if (i % 16 == 0):
                # Apply RotByte transformation
                inter = temp[0]
                temp[0] = temp[1];
                temp[1] = temp[2];
                temp[2] = temp[3];
                temp[3] = inter;

                # Apply SubByte transformation
                temp[0] = self.sbox[temp[0].astype(np.uint8)];
                temp[1] = self.sbox[temp[1].astype(np.uint8)];
                temp[2] = self.sbox[temp[2].astype(np.uint8)];
                temp[3] = self.sbox[temp[3].astype(np.uint8)];

                # Apply Rcon transformation
                temp[0] ^= self.rcon[i // 16];

            # The next word of the ExpandedKey is equal to the bitwise EXOR
            # of the current last word and the word came 4 words before the
            # word that is currently computed
            expandedkey[i : i + 4] = expandedkey[i - 16 : i - 12] ^ temp
            i += 4

        end = time.time()
        return expandedkey, end - start


def test1_KeyExpansionTest():
    # Number of rounds is 10 for key length 16
    nr_rounds = 10

    # Input array
    hex_in = "2b7e151628aed2a6abf7158809cf4f3c"
    byte_in = bytes.fromhex(hex_in)
    byte_array_in = np.frombuffer(byte_in, dtype=np.byte)

    # Reference output
    hex_ref  = "2b7e151628aed2a6abf7158809cf4f3c"
    hex_ref += "a0fafe1788542cb123a339392a6c7605"
    hex_ref += "f2c295f27a96b9435935807a7359f67f"
    hex_ref += "3d80477d4716fe3e1e237e446d7a883b"
    hex_ref += "ef44a541a8525b7fb671253bdb0bad00"
    hex_ref += "d4d1c6f87c839d87caf2b8bc11f915bc"
    hex_ref += "6d88a37a110b3efddbf98641ca0093fd"
    hex_ref += "4e54f70e5f5fc9f384a64fb24ea6dc4f"
    hex_ref += "ead27321b58dbad2312bf5607f8d292f"
    hex_ref += "ac7766f319fadc2128d12941575c006e"
    hex_ref += "d014f9a8c9ee2589e13f0cc8b6630ca6"
    byte_ref = bytes.fromhex(hex_ref)
    byte_array_ref = np.frombuffer(byte_ref, dtype=np.byte)

    graphicscomputer = KeyExpansionTest()
    result_gpu = graphicscomputer.keyexpansion_gpu(byte_array_in, nr_rounds)
    print("GPU Time for KeyExpansion: ", result_gpu[1])
    assert np.array_equal(result_gpu[0], byte_array_ref)

def test2_KeyExpansionTest():
    # Number of rounds is 10 for key length 16
    nr_rounds = 10

    # Input array
    hex_in = "2b7e151628aed2a6abf7158809cf4f3c"
    byte_in = bytes.fromhex(hex_in)
    byte_array_in = np.frombuffer(byte_in, dtype=np.byte)

    # Reference output
    hex_ref  = "2b7e151628aed2a6abf7158809cf4f3c"
    hex_ref += "a0fafe1788542cb123a339392a6c7605"
    hex_ref += "f2c295f27a96b9435935807a7359f67f"
    hex_ref += "3d80477d4716fe3e1e237e446d7a883b"
    hex_ref += "ef44a541a8525b7fb671253bdb0bad00"
    hex_ref += "d4d1c6f87c839d87caf2b8bc11f915bc"
    hex_ref += "6d88a37a110b3efddbf98641ca0093fd"
    hex_ref += "4e54f70e5f5fc9f384a64fb24ea6dc4f"
    hex_ref += "ead27321b58dbad2312bf5607f8d292f"
    hex_ref += "ac7766f319fadc2128d12941575c006e"
    hex_ref += "d014f9a8c9ee2589e13f0cc8b6630ca6"
    byte_ref = bytes.fromhex(hex_ref)
    byte_array_ref = np.frombuffer(byte_ref, dtype=np.byte)

    graphicscomputer = KeyExpansionTest()
    result_cpu = graphicscomputer.keyexpansion_cpu(byte_array_in, nr_rounds)
    print("CPU Time for KeyExpansion: ", result_cpu[1])
    assert np.array_equal(result_cpu[0], byte_array_ref)

test1_KeyExpansionTest()
test2_KeyExpansionTest()
