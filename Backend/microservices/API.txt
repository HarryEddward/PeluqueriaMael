/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/config.py
from Backend.microservices.conversor.config.config import Config

config: dict = Config()
app: str = config['app']

host: str = app['API']['testing']['host']
port: str = app['API']['net']['port']
ssl: str = app['API']['ssl']
protcol: str = 'https' if ssl else 'http'


BASE_URL: str = f"{protcol}://{host}:{port}"

login_credentials: dict = {
  "email": "adrianbestloginuser@gmail.com",
  "password": "Dark_Draw_Everything"
}

delete_credentials: dict = {
    "email": "user_adrian_delete@gmail.com",
    "password": "PopThatShit"
}

register_credentials: dict = {
    "email": "new_user_register_deleteab@gmail.com",
    "password": "NewPasswordForThat"
}

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_booking.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials
from Backend.microservices.app.API.v1.logging_config import logger

class Config:
    id_appointment: str = ""

    @classmethod
    def set_id_appointment(cls, appointment_id: str):
        cls.id_appointment = appointment_id

    @classmethod
    def get_id_appointment(cls) -> str:
        return cls.id_appointment

@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
@pytest.mark.order(1)
def test_booking_add():
    data: dict = login_credentials

    try:
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            #print(response)

            assert response.status_code == 200

            response_json: dict = response.json()

            cprint(f"\nResponse: {response_json}\n", "green", "on_black")
            
            data_appointment: dict = {
                "token_id": response_json["token_id"],
                "token_data": response_json["token_data"],
                "day_date": 19,
                "month_date": 9,
                "year_date": 2024,
                "hour": "17:30",
                "period": "afternoon",
                "name_service": "corte_de_pelo"
            }


            print(data_appointment)

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/booking/add",
                json=data_appointment
            )

            logger.info(f"ADD APPONITMENT: {response.json()}")

            assert response.status_code == 200

            response_json = response.json()
            print(response_json)

            # Guardar el id_appointment en Config
            Config.set_id_appointment(response_json["data"]["id_appointment"])

    except httpx.RequestError as e:
        print(f"Request failed: {e}")

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
@pytest.mark.order(2)
def test_booking_remove():
    data: dict = login_credentials
    print(BASE_URL)

    try:
        with httpx.Client() as client:

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            print(response)

            assert response.status_code == 200

            response_json: dict = response.json()

            cprint(f"\nResponse: {response_json}\n", "green", "on_black")

            # Usar el id_appointment guardado en Config
            id_appointment = Config.get_id_appointment()
            
            data_appointment: dict = {
                "token_id": response_json["token_id"],
                "token_data": response_json["token_data"],
                "id_reserva": "2df6dd7b-fb56-4f14-b17d-81fced9fdbad" #id_appointment
            }

            print(data_appointment)

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/booking/remove",
                json=data_appointment
            )

            logger.info(f"REMOVE APPONITMENT: {response.json()}")

            assert response.status_code == 200

            #logger.info(f"REMOVE APPONITMENT: {response.json()}")

            print(response.json())

    except httpx.RequestError as e:
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_data_appointments.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials
from Backend.microservices.app.API.v1.logging_config import logger

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_data_appointments():
    #email: str = "exampleandrian@gmail.com"
    #password: str = "fuck_you"
    
    data: dict = login_credentials

    #print(BASE_URL)

    try:
        # Desactiva la verificación de certificados SSL en httpx
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            print(response)

            logger.info(f"DATA APPPONITMENTS: {response.json()}, {response.status_code}")
            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta
            response_json: dict = response.json()

            # Imprime el contenido de la respuesta
            cprint(f"\nResponse: {response_json}\n", "green", "on_black")


            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/data/appointments",
                json=response_json
            )

            assert response.status_code == 200

            print(response.json())

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_data_booking_day_sheet.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_data_booking():
    #email: str = "exampleandrian@gmail.com"
    #password: str = "fuck_you"
    
    data: dict = login_credentials
    #print(BASE_URL)

    try:
        # Desactiva la verificación de certificados SSL en httpx
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            print(response)

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta
            response_json: dict = response.json()

            response_json["day"] = 28
            response_json["month"] = 9
            response_json["year"] = 2024

            # Imprime el contenido de la respuesta
            cprint(f"\nResponse: {response_json}\n", "green", "on_black")


            response_data_booking: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/data/booking_day_sheet",
                json=response_json
            )

            assert response_data_booking.status_code == 200

            print(response.json())

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_data_services.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_data_services():
    #email: str = "amigodospuntozero10191sduds@gmail.com"
    #password: str = "fuck_yo"
    
    data: dict = login_credentials
    #print(BASE_URL)

    try:
        # Desactiva la verificación de certificados SSL en httpx
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            print(response)

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta
            response_json = response.json()

            # Imprime el contenido de la respuesta
            cprint(f"\nResponse: {response_json}\n", "green", "on_black")

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/data/services",
                json=response_json
            )

            assert response.status_code == 200

            print(response.json())


    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_login.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials
from Backend.microservices.app.API.v1.logging_config import logger

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_login():
    #email: str = "amigodospuntozero10191sduds@gmail.com"
    #password: str = "fuck_yo"
    
    data: dict = login_credentials
    #print(BASE_URL)

    try:
        # Desactiva la verificación de certificados SSL en httpx
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data
            )
            print(response)
            logger.info(f"RES LOGIN: {response.json()}, {response.status_code}")

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta
            response_json: dict = response.json()

            # Imprime el contenido de la respuesta
            cprint(f"\nResponse: {response_json}\n", "green", "on_black")

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_register.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, register_credentials

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_register():
    #email: str = "amigodospuntozero10191sduds@gmail.com"
    #password: str = "fuck_yo"
    
    data: dict = register_credentials

    try:
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/register",
                json=data
            )

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta en formato JSON
            response_json: dict = response.json()

            # Verifica que el JSON contenga las claves 'token_id' y 'token_data'
            assert "token_id" in response_json, "'token_id' not found in response"
            assert "token_data" in response_json, "'token_data' not found in response"

            # Imprime el contenido de la respuesta (puedes comentar esto si no es necesario)
            cprint(f"\nResponse JSON: {response_json}\n", "green", "on_black")
            
            response_json["verify"] = True
            print(response_json)

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/user/delete",
                json=response_json
            )

            print(response.content)

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_user_config_reset_password.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, login_credentials
from Backend.microservices.app.API.v1.logging_config import logger

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_user_config_reset_password():
    #email: str = "exampleandrian@gmail.com"
    #password: str = "fuck_you"
    
    data_login: dict = login_credentials
    #print(BASE_URL)

    try:
        # Desactiva la verificación de certificados SSL en httpx
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/login",
                json=data_login
            )

            logger.info(f"USER CONFIG: {response.json()}")

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta
            response_json: dict = response.json()

            # Imprime el contenido de la respuesta
            cprint(f"\nResponse: {response_json}\n", "green", "on_black")

            response_json["current_psw"] = data_login["password"]
            response_json["new_psw"] = data_login["password"]

            logger.info(f"USER CONFIG: {response_json}")

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/user/config/reset_password",
                json=response_json
            )

            logger.info(f"USER CONFIG: {response.json()}")

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            print(response.json())

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/routes/test_user_delete.py
import pytest
import httpx
from termcolor import cprint
from Backend.microservices.app.API.v1.__tests__.routes.config import BASE_URL, delete_credentials
from Backend.microservices.app.API.v1.logging_config import logger

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_user_delete():
    #email: str = "adriansupalumbedsadsarasddsadgssdaasasadsadsdmarkzukrb191010@gmail.com"
    #password: str = "fuck_yo"
    
    data: dict = delete_credentials
    try:
        with httpx.Client() as client:
            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/public/register",
                json=data
            )
            
            logger.info(f"REGISTER DELTE USER: {response.json()}")

            # Verifica el código de estado HTTP
            assert response.status_code == 200

            # Obtén el contenido de la respuesta en formato JSON
            response_json: dict = response.json()

            # Verifica que el JSON contenga las claves 'token_id' y 'token_data'
            assert "token_id" in response_json, "'token_id' not found in response"
            assert "token_data" in response_json, "'token_data' not found in response"

            # Imprime el contenido de la respuesta (puedes comentar esto si no es necesario)
            cprint(f"\nResponse JSON: {response_json}\n", "green", "on_black")
            
            response_json["verify"] = True
            logger.info(response_json)

            response: httpx.Response = client.post(
                f"{BASE_URL}/api/app/api/v1/client/restricted/user/delete",
                json=response_json
            )

            logger.info(f"USER DELETE: {response.json()}, {response.status_code}")

            print(response.content)

    except httpx.RequestError as e:
        # Manejo de excepciones de la librería httpx
        print(f"Request failed: {e}")


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/__tests__/test_shared_microservices_cryptoapi.py
import pytest
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import EncryptText, encrypt, decrypt
from pydantic import ValidationError
from termcolor import cprint

# Pruebas para la validación de texto

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_valid_ascii_text():
    assert EncryptText(text='Hello World') == EncryptText(text='Hello World')

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_invalid_ascii_text():
    with pytest.raises(ValidationError):
        EncryptText(text='Hello\x00World')

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_valid_text_with_permitted_characters():
    assert EncryptText(text='Hello, World!') == EncryptText(text='Hello, World!')

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
"""def test_invalid_text_with_special_characters():
    with pytest.raises(ValidationError):
        EncryptText(text='Hello @#%')
"""

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_invalid_utf8_text():
    with pytest.raises(ValidationError):
        EncryptText(text='Café')

# Mock para la lógica de encriptación y desencriptación

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_encrypt():
    # Simulación del comportamiento esperado para pruebas
    mock_text = 'Hello World'
    result = encrypt(mock_text)
    assert isinstance(result, str)  # Verificar que el resultado es de tipo bytes

#@pytest.mark.skip(reason="Esta prueba está deshabilitada temporalmente.")
def test_decrypt():
    # Simulación del comportamiento esperado para pruebas
    encrypted_text = encrypt('Hello World')
    assert isinstance(encrypted_text, str)
    print("\n")
    cprint(encrypted_text, "green", "on_black")
    result = decrypt(encrypted_text)
    cprint(result, "green", "on_black")
    print("\n")
    assert isinstance(result, str)  # Verificar que el resultado es de tipo bytes
    assert result == 'Hello World'


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/config/middlewares/client/handleError.py
# handleMiddleware.py

from fastapi import Request, FastAPI
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

class ErrorMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            # Puedes personalizar el manejo de errores aquí
            return JSONResponse(
                status_code=500,
                content={
                    "info": "Ha ocurrido un error interno en el servidor.",
                    "status": "no",
                    "type": "GLOBAL_ERROR"
                }
            )

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/config/middlewares/client/restricted.py
from fastapi import Request, Response, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Callable, Awaitable
from bson import ObjectId
from crud.mongodb.users.find import FindUser, FindSecretJWTID
from crud.mongodb.users.update import UpdateUser
from services.auth import JWToken
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt
from Backend.microservices.app.API.v1.logging_config import logger


class RestrictedMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: Callable[[Request], Awaitable[Response]]):
        logger.info('Entra en el middleware')
        logger.info(request.url.path)
        #/api/app/api/v1/client/restricted/user/delete
        if request.url.path.startswith("/api/app/api/v1/client/restricted/"):

            #logger.info(f"PATH: {request.url.path}")
            if request.method == "POST":
                logger.info("Es tipo post!")
                try:
                    body = await request.json()
                    token_id = body["token_id"]
                    token_data = body["token_data"]

                    logger.info("Token_ID: %s", token_id)
                    logger.info("Token_Data: %s", token_data)


                    token_id_check = JWToken.check(token_id) # Clave JWT Global
                    

                    if token_id_check["status"] == "ok":
                        
                        #print('->',token_id_check["data"]["info"])
                        
                        user_id: str = token_id_check["data"]["info"]
                        decrypted_user_id: str = decrypt(user_id)
                        

                        #Si el token_id esta correcto, irá a buscar el usuario en el db
                        secret = FindUser.secret_jwt(
                            FindSecretJWTID(
                                id=decrypted_user_id
                            )
                        )
                        

                        #Si encontro el secreto en el usuario y todo salio bien
                        if secret.response["status"] == 'ok':

                            #print('entro')
                            #Teniendo el secreto descifraremos el segundo token con la clave privada secreta que tiene el mismo usuario
                            user_secret = secret.response["data"]

                            decrypted_user_secret_key: str = decrypt(user_secret)
                            #print('')

                            token_data_check = JWToken.check(token_data, decrypted_user_secret_key)
                            #print('->', token_data_check)
                            
                            
                            if token_data_check["status"] == 'ok':
                                
                                #print(token_data_check)
                                email: str = token_data_check["data"]["info"]["email"]
                                password: str = token_data_check["data"]["info"]["password"]
                                
                                #print('here!')
                                #Añades las credenciales para luego recrear una nueva clave del secreto del usuario
                                renew_secret = UpdateUser.secret_jwt({
                                    "email": email,
                                    "password": password,
                                })
                                #print('final ->>>>')
                                #Intenta modificar la clave secreta del usuario 
                                if renew_secret.response["status"] == 'ok':

                                    new_token = renew_secret.response["data"]["token"]
                                    request.state.new_token = str(new_token)
                                    request.state.email = str(email)
                                    request.state.password = str(password)
                                    request.state.user_id = str(decrypted_user_id)

                                    logger.info(f'new_token: {request.state.new_token}')
                                else:
                                    return JSONResponse(renew_secret.response, 401)

                            else:
                                return JSONResponse({
                                    "more": token_data_check,
                                    "type_token": "token_data"
                                }, 401)

                        else:
                            return JSONResponse(secret.response, 401)
                        

                    else:
                        return JSONResponse({
                            "info": token_id_check["info"],
                            "status": token_id_check["status"],
                            "type": token_id_check["type"],
                            "type_token": "token_id"
                        }, 401)
                    

                except Exception as e:
                    return JSONResponse({
                        "info": f"Hubo un error inesperado: {e}",
                        "status": "no",
                        "type": "UNKNOW_ERROR"
                    }, status_code=401)
            elif request.method == "OPTIONS":
                pass
            else:
                return JSONResponse({
                    "info": "En las rutas: /app/api/v1/client/restricted/, solo esta permitido el método: POST",
                    "status": "no",
                    "type": "INVALID_METHOD"
                })
        return await call_next(request)       

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/config/config.py


conf: dict = {
    "db": {
        "services": "65ec5f9f88701955b30661a5"
    }
}

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/utils/remove/verifyDays.py
from datetime import datetime, timedelta
from numpy import ushort
import numba as nb
from abc import ABC, abstractmethod
from Backend.microservices.app.API.v1.logging_config import logger


class Verify(ABC):

    @abstractmethod
    def __init__(self) -> None:
        super().__init__()
        pass

    @abstractmethod
    def verify(self) -> dict:
        pass

class verifyDays(Verify):

    #@nb.jit(nopython=True)
    def __init__(
            self,
            day: ushort,
            month: ushort,
            year: ushort
        ) -> None:
        self.day = day
        self.month = month
        self.year = year
        self.response = self.verify()

    #@nb.jit(nopython=True)
    def verify(self) -> dict:
        # Obtener la fecha actual
        current_date = datetime.now().date()

        # Crear objeto de fecha para la reserva
        reservation_date = datetime(self.year, self.month, self.day)
        reservation_date = reservation_date.date()

        #print('Tipo de current_date:', type(current_date))
        #print('Tipo de reservation_date:', type(reservation_date))


        # Calcular la diferencia entre las fechas
        difference = reservation_date - current_date
        #print('diference of the days: ', difference.days)

        # Si el número de dias es negativo es porque ya pasó la reserva, y si por algun motivo lo enseña al cliente pueda borrarlo. Pero seria problema del diseño de la API
        if difference.days < 0:
            return {
                "info": "La fecha de reserva es en el pasado. La reserva puede ser eliminado.",
                "status": "ok",
                "type": "SUCCESS"
            }

        logger.info(f"VerifyDays: difference -> {difference}, {timedelta(days=3)}")

        # Verificar si faltan al menos 3 días para la reserva
        if not difference >= timedelta(days=3):
            
            return {
                "info": "No puede cancelar la reserva. Faltan menos de tres días.",
                "status": "no",
                "type": "LIMITED_EXCEEDED"
            }

            
        return {
            "info": "Tiene acceso a cancelar la reserva.",
            "status": "ok",
            "type": "SUCCESS"
        }
            
/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/utils/conversorServices.py
from pydantic import BaseModel
from datetime import timedelta
from bson import ObjectId
from abc import ABC, abstractmethod

from Backend.microservices.app.API.v1.db.mongodb.database import configure


'''class Verify(ABC):
    @abstractmethod
    def convert(self) -> dict:
        pass
'''

class conversorServices:
    '''
    SI -> Obtiene todos los servicios guardados en cofiguración
    NO -> Obtiene el id de configruation db de la coleccion y leugo devuelve todo el personal en difernetes
    arrays
    '''

    '''
    Que quiero hacer?
    Quiero que obtenga la version de la ficha del dia a reservar, y pase la version para que obtenga, devolver
    una diccionario compatible de ese dia con ese personal.

    Por cada dia que pase, se crea una ficha y en cada ficha obtiene el personal mas reciente y añade la version mas
    actualizada, para evitar problemas de compatabilidad y prevenir errores inesperados
    '''

    def __init__(self) -> dict:
        
        '''version -> v1, v2, v3 of services'''
        self.response = {}
        services_raw = configure.find_one({ "_id": ObjectId("65ec5f9f88701955b30661a5") })
        


        #print('services_raw ->', services_raw)
        dict_services = {}

        for service in services_raw['services']:
            service_name = service['nombre']

            
            #Verifica si las horas no superan de las 4 horas, y si en los minutos son de 0 o 30 minutos
            verify_hour = service['duracion']['horas'] >= 0 and service['duracion']['horas'] <= 4
            verify_minutes = service['duracion']['minutos'] == 0 or service['duracion']['minutos'] == 30

            if verify_hour and verify_minutes:
                duration = timedelta(hours=service['duracion']['horas'], minutes=service['duracion']['minutos'])
                service_type = service['tipo']
                dict_services[service_name] = [duration, service_name, service_type]

                self.response = {
                    "info": "Conversión de los servicios éxitosa",
                    "status": "ok",
                    "type": "SUCCESS",
                    "data": dict_services
                }
            else:
                if not verify_hour:
                    self.response = {
                        "info": "Las horas no cumplen con la condición, deben ser mayor a 0 y menor/igual a 4",
                        "status": "no",
                        "type": "VERIFY_HOUR_ERROR"
                    }
                    break

                if not verify_minutes:
                    self.response = {
                        "info": "Los minutos no son validos, no cumplen con la condicion de 0/30 minutos",
                        "status": "no",
                        "type": "VERIFY_MINUTES_ERROR"
                    }
                    break
        
        #print('dict_services ->', dict_services)
        #print(dict_services)


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/utils/serviceToPersonal.py
from bson import ObjectId
from pydantic import BaseModel
import numba as nb
from Backend.microservices.app.API.v1.db.mongodb.database import configure, personal


class serviceToPersonal:

    #Think about change to "structure" the name
    class service(BaseModel):
        service: str
    
    #@nb.jit(nopython=True)
    def __init__(self, data: service) -> None:
        self.response = {}

        '''
        Se usa para obtener el personal de ese servicio, un método de verificación
        de los servicios existente contra aquellos que no tienen.

        El tipo de cada servicio se refiere al personal, que el personal hace ese
        servicio

        Example:

        serviceToPersonal(
            serviceToPersonal.service(
                service="peinar_con_secador"
            )
        )

        Response = {
                "info": "Devolucion del servicio el tipo de personal",
                "status": "ok",
                "type": "SUCCESS",
                "data": personal del servicio
            }
        '''

        service_name = data.service  # Acceder al atributo 'service' de la instancia 'data'

        try:
            #raw_personal = configure.find_one({ "_id": ObjectId("661f915fac2b216927f37257") })
            raw_services = configure.find_one({ "_id": ObjectId("65ec5f9f88701955b30661a5") })
        except Exception as e:
            self.response = {
                "info": f"Error en la base de datos: {e}",
                "status": "no",
                "type": "DATABASE_ERROR"
            }
            return

        #personal = raw_personal['personal']
        services = raw_services['services']

        # Buscar el servicio por nombre y obtener su tipo
        tipo_servicio = None
        for servicio in services:
            if servicio["nombre"] == service_name:
                tipo_servicio = servicio["tipo"]
                break

        if tipo_servicio is None:
            self.response = {
                "info": f"El servicio {service_name} no existe.",
                "status": "no",
                "type": "SERVICE_NOT_FOUND"
            }
        else:
            self.response = {
                "info": "Devolucion del servicio el tipo de personal",
                "status": "ok",
                "type": "SUCCESS",
                "data": tipo_servicio
            }


"""print(serviceToPersonal(
    serviceToPersonal.service(
        service="peinar_con_secador"
    )
).response["data"])"""

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/utils/workerLessBusy.py
from pydantic import BaseModel
from typing import List

class workerLessBusy:

    class structure(BaseModel):
        rama_profesionales: List[str]
        professionals: dict

    #@nb.jit(nopython=True)
    def __init__(self, data: structure) -> None:

        try:
            ocupacion_profesionales = []

            data = data.model_dump()
            rama_profesionales = data["rama_profesionales"]
            professionals = data["professionals"]["professionals"]

            print('professionals->', professionals)

            '''
            Cuando se modifica los trabajadores en la parte de el array de cada uno de los profesionales,
            los nuevos dias que se crean se hacen con los nuevos trabajadores 
            '''

            for profesional in rama_profesionales:
                contador_ocupado = 0
                for periodo in professionals[profesional]:
                    for hora, estado in professionals[profesional][periodo].items():
                        if estado["status"] == "ocupado":
                            contador_ocupado += 1
                ocupacion_profesionales.append((profesional, f"{contador_ocupado/2}h")) #Se divide en 2, porque hacemos uso de 30', y tendremos una hora por 2 medias horas

            ocupacion_profesionales.sort(key=lambda x: x[1])

            self.response = {
                "info": "Entragado los profesionales menos ocupados",
                "status": "ok",
                "type": "SUCCESS",
                "data": ocupacion_profesionales
            }
        except Exception as e:
            self.response = {
                "info": f"Error desconocido: {e}",
                "status": "no",
                "type": "UNKNOW_ERROR"
            }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/validate/count_appointments.py
from typing import Any
from pydantic import BaseModel
from abc import ABC, abstractmethod
from typing import Union
from bson import ObjectId
from Backend.microservices.conversor.config.config import Config
from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.logging_config import logger


class Verify(ABC):
    
    def __call__(self) -> Union[dict, Exception]:
        pass
    
    def obtain_appointments(self) -> Union[list, Exception]:
        pass

    def evaluate_results(self) -> Union[dict, Exception]:
        pass

class CountAppointmentsModel(BaseModel):
    user_id: str

class CountAppointments(Verify):


    def __init__(self) -> None:
        self.max_appointments: dict = Config()
        self.max_appointments: str = self.max_appointments["app"]["API"]["validation"]["user"]["max_appointments"]

    def __call__(self, data_raw: CountAppointmentsModel) -> Union[dict, Exception]:
        
        try:
            data: dict = data_raw.model_dump()
            self.user_id: str = data["user_id"]
        except Exception as e:
            return {
                "info": "Error a la extracción de los datos validados",
                "status": "no",
                "type": "PYDANTIC_ERROR_EXTRACTION"
            }
        
        try:
            self.list_appointments: list = self.obtain_appointments()
        except Exception as e:
            return {
                "info": "Error a la hora de buscar en la base de datos el usuario",
                "status": "no",
                "type": "DATABASE_ERROR"
            }
        
        try:
            result = self.evaluate_results(self.list_appointments)

            if not result:
                return {
                    "info": f"Solo se permiten máximo {self.max_appointments} reservas en tu perfil",
                    "status": "no",
                    "type": "EXCEDED_DAYS"
                }
            
            return {
                "info": "Puedes hacer tu reserva de forma exitosa",
                "status": "ok",
                "type": "SUCCESS"
            }

        except Exception as e:
            return {
                "info": "Error a la hora de evaular las reservas",
                "status": "no",
                "type": "EVALUATE_ERROR"
            }
    
    def obtain_appointments(self) -> Union[list, Exception]:
        """
        Devulve una lista sobre las reservas que tiene, si no tiene
        devuelve una lista vacia, y si las hay obtiene el id's de las
        reservas.

        Returns:
            Union[list, Exception]: [description]
        """

        document: dict = users.find_one({"_id": ObjectId(self.user_id)})
        #logger.info(f"DOC: {document}")

        count: Union[None, dict] = document["data"]["reservas"]
        
        if not count:
            return []
        
        return count.keys()


    def evaluate_results(self, data: list) -> Union[dict, Exception]:

        """
        Evalua si supera el maximo permitido de reservas, si supera
        el máximo permitido dara un resultado negativo [False] y de
        froma dinamica se puede controlar a partir de un archivo yml
        el máximo permitido de reservas.

        Returns:
            [bool]: [Devuelve un resultado negativo o positivo]
        """
        
        return len(data) < self.max_appointments



if __name__ == "__main__":
    data_count_appointments = CountAppointmentsModel(user_id="66d624307bdc4aff296819f9")
    count_appointments = CountAppointments()
    result = count_appointments(data_count_appointments)
    print(result)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/add.py
import datetime
from .config import config
import uuid
from bson import ObjectId
from pydantic import BaseModel
from datetime import datetime, timedelta
from abc import ABC, abstractmethod
import numpy as np
from numpy import short
import numba as nb
from crud.mongodb.users.booking.add import AddBookingUser, AddAppointment
from Backend.microservices.app.API.v1.db.mongodb.database import reservas
from Backend.microservices.app.API.v1.db.mongodb.database import configure
from Backend.microservices.app.API.v1.logging_config import logger

class Verify(ABC):
    @abstractmethod
    def __init__(self, data_raw: BaseModel):
        pass

    @abstractmethod
    def buscar_disponibilidad(self, data_raw: BaseModel):
        pass

    @abstractmethod
    def add(self, data_raw: BaseModel, professional_selected: str):
        pass

class AddBooking(Verify):

    class structure(BaseModel):
        day: int
        month: int
        year: int
        professionals: list
        period: str
        start_time: str
        service_duration: timedelta
        person_id: str
        service: str

        '''
        Example = {
            Scheme(
                day: str
                professional: str
                period: str
                start_time: str
                service_duration: str
                person_id: str
                service: str

                day=0,
                month=0,
                year=2024,
                professional="peluquero_2",
                period="afternoon",
                start_time: "17:00",
                service_duration: services['corte_de_pelo'][0],
                person_id: "65ec610288701955b30661a8",
                service: "corte_de_pelo"
            )
        }

        Response = {
            "info": f"Cita confirmada para {professional} desde {start_time} hasta {end_time}.",
            "status": "ok",
            "type": "SUCCESS"  # Tipo de error único
        }
        
        '''

    #@nb.jit(nopython=True)
    def __init__(self, data_raw: structure):
        try:
            self.response = self.buscar_disponibilidad(data_raw)
            #print('aq')
            #print(self.response)
            
        except Exception as e:
            self.response = {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "UNKNOWN_ERROR"
            }
            return

    #@nb.jit(nopython=True)
    def buscar_disponibilidad(self, data_raw):
        data = data_raw.model_dump()
        professionals = data["professionals"]

        # Itera sobre los profesionales en orden de menos ocupado a más ocupado
        for professional, _ in professionals:
            resultado = self.add(data_raw, professional)

            #print('---->', resultado)
            if resultado["status"] == "ok":
                #print('lo conseguio')
                return resultado
                
            elif resultado["status"] == "no" and resultado["type"] == "PROFESSIONAL_BUSSY":
                #print('cointunue...')
                continue
            else:
                #print('no without->', resultado)
                return resultado

        #print('acabo sin anda')
        # Si todos los profesionales están ocupados
        return {
            "info": "Todos los profesionales están ocupados en este momento.",
            "status": "no",
            "type": "NO_AVAILABILITY"
        }
    
    #@nb.jit(nopython=True)
    def add(self, data_raw, professional_selected: str):
        self.response = {}

        try:
            data = data_raw.model_dump()
            day: short = data["day"]
            month: short = data["month"]
            year: short = data["year"]
            professional: str = professional_selected
            period: str = data["period"]
            start_time: str = data["start_time"]
            service_duration: timedelta = data["service_duration"]
            person_id: str = data["person_id"]
            service: str = data["service"]
            #Obtiene la información de la reserva desde la base de datos del día especficado
            day_date = datetime(year, month, day)
            try:
                day_appointment = reservas.find_one({"fecha": {"$eq": day_date}})
            except Exception as e:
                
                self.response = {
                    "info": f"Error al programar la cita en la base de datos: {e}",
                    "status": "no",
                    "type": "DATABASE_ERROR"  # Tipo de error único
                }
                return

            #services = conversorServices(services_raw)
            professionals = day_appointment.get('professionals')
            #print('reservo')


            morning_opening_time = config["morning_opening_time"]
            morning_closing_time = config["morning_closing_time"]
            afternoon_opening_time = config["afternoon_opening_time"]
            afternoon_closing_time = config["afternoon_closing_time"]

            #Verifica si tiene menos de 4 caracteres Ok(09:00) No(9:00)
            if len(start_time) == 4:
                #print('len')
                # Si falta algún zero se le añade, se supone que si la hora se queda a 4 caracteres es por la falta de ese 0.
                start_time = "0"+start_time

            # Si realmente no cumple con la longitud de la misma cadena no es una hora
            elif 4 > len(start_time) > 5:
                #print('len2')
                return {
                    "info": f"No es una hora valida, por lo visto: {start_time}",
                    "status": "no",
                    "type": "INVALID_HOUR"
                }
            #print(start_time)

            start_time_dt = datetime.strptime(start_time, '%H:%M')  # Convertir start_time a datetime
            #print(start_time_dt)

            if period == 'morning':
                if start_time_dt < morning_opening_time or start_time_dt >= morning_closing_time:
                    return {
                        "info": "No se puede programar una cita en la mañana fuera del horario de apertura y cierre.",
                        "status": "no",
                        "type": "OUT_TRY_BOOKING"
                    }
            elif period == 'afternoon':
                #print(start_time_dt, afternoon_closing_time, '|', start_time_dt, afternoon_opening_time)
                if start_time_dt < afternoon_opening_time or start_time_dt >= afternoon_closing_time:
                    return {
                        "info": "No se puede programar una cita en la tarde fuera del horario de apertura y cierre.",
                        "status": "no",
                        "type": "OUT_TRY_BOOKING"
                    }
                    

            id_appointment = str(uuid.uuid4())
            
            if period not in professionals[professional]:
                return {
                    "info": "El período especificado no es válido para este profesional.",
                    "status": "no",
                    "type": "ERROR1"  # Tipo de error único
                }

            morning_schedule = professionals[professional]['morning']
            last_hour_morning = str(max(morning_schedule.keys(), key=lambda x: datetime.strptime(x, "%H:%M")))
            #print('aqux')
            
            

            if period == 'morning' and start_time >= last_hour_morning:
                #print('start_time ->', start_time)
                #print('last_hour_morning ->', last_hour_morning)

                #print(f'{start_time}, {last_hour_morning} = {start_time >= last_hour_morning}')
                #print(f'{period} == "morning", {period == 'morning'}')

                #print(start_time >= last_hour_morning)
                return {
                    "info": "No se puede programar una cita en la mañana después del mediodía.",
                    "status": "no",
                    "type": "ERROR2"
                }
            
            
            if period == 'afternoon' and start_time < last_hour_morning:
                return {
                    "info": "No se puede programar una cita en la tarde antes del mediodía.",
                    "status": "no",
                    "type": "ERROR3"
                }
            
            


            '''
            Procurar que sean exactamente igual los valores que se valida la hora,
            deben de ser 5 caracteres, y no 4.
            Esto esta mal -> 9:00
            Esto esta bien -> 09:00
            '''

            if start_time in professionals[professional][period]:

                #print(f'EL PROFESSIONAL {professionals[professional]} tiene el {start_time}')
                end_time = (datetime.strptime(start_time, '%H:%M') + service_duration).strftime('%H:%M')
                end_time_plus_half_hour = (datetime.strptime(end_time, '%H:%M') + timedelta(minutes=30)).strftime('%H:%M')


                # Verificar si la cita programada se extiende más allá del horario de cierre de la mañana o tarde
                if period == 'morning' and datetime.strptime(end_time, '%H:%M') > morning_closing_time:
                    return {
                        "info": f"No se puede programar la cita para {professional} después del horario de cierre de la mañana.",
                        "status": "no",
                        "type": "OUT_SCHULDE_BEFORE_MORNING"  # Tipo de error único
                    }
                elif period == 'afternoon' and datetime.strptime(end_time, '%H:%M') > afternoon_closing_time:
                    return {
                        "info": f"No se puede programar la cita para {professional} después del horario de cierre de la tarde.",
                        "status": "no",
                        "type": "OUT_SCHULDE_AFTER_AFTERNOON"  # Tipo de error único
                    }

                available_slots = np.array(list(professionals[professional][period].items()))
                #available_slots = set(professionals[professional][period].keys())

                
                # Verificar si algún intervalo parcial está disponible
                start_datetime = datetime.strptime(start_time, '%H:%M')
                end_datetime = datetime.strptime(end_time, '%H:%M')
                end_datetime_plus_half_hour = datetime.strptime(end_time_plus_half_hour, '%H:%M')
                
                overlapping_slots = [
                    (slot, status) for slot, status in available_slots
                    if start_datetime <= datetime.strptime(slot, '%H:%M') < end_datetime_plus_half_hour
                ]
                
                #print('reservo')
                # Verificar si hay algún solapamiento en la franja horaria
                if overlapping_slots and any(status["status"] == 'ocupado' for _, status in overlapping_slots):
                    print('entro')
                    return {
                        "info": f"No se puede programar la cita para {professional} en la franja horaria solicitada.",
                        "status": "no",
                        "type": "PROFESSIONAL_BUSSY"  # Tipo de error único
                    }
                    #print('add self.response->', self.response)
                    

                #print('asd')
                # Marcar el intervalo parcial como ocupado y guardar la información de la cita
                #logger.info(f"END TIME PLUS: {end_datetime_plus_half_hour}")
                for slot, _ in available_slots:
                    #logger.info(f"SLOT: {slot}")
                    #logger.info(f"AVAILABLE_SLOTS: {available_slots}")
                    if start_datetime <= datetime.strptime(slot, '%H:%M') < end_datetime_plus_half_hour:
                        professionals[professional][period][slot] = {
                            "status": 'ocupado',
                            "info": {
                                "person_id": person_id,
                                "service": service,
                                "id_appointment": id_appointment,
                                
                            }
                        }
                        if slot != start_time:  # Solo limpiar 'info' en las franjas horarias distintas a la seleccionada
                            professionals[professional][period][slot].pop("info", None)

                
                #print('pro ->', professional)
                dataUserAppointment = AddAppointment(
                    day=day,
                    month=month,
                    year=year,
                    responsable_appointment=professional,
                    id_appointment=id_appointment,
                    period=period,
                    start_time=start_time,
                    person_id=person_id,
                    service=service
                )

                addUserAppointment = AddBookingUser(dataUserAppointment)

                if addUserAppointment.response and addUserAppointment.response["type"] == "DATABASE_ERROR":
                    return addUserAppointment

                
                try:
                    # Actualizar el documento en la base de datos
                    update_result = reservas.update_one(
                        {"fecha": {"$eq": day_date}},
                        {"$set": {"professionals": professionals}}
                    )
                except Exception as e:
                    return {
                        "info": f"Error al programar la cita en la base de datos: {e}",
                        "status": "no",
                        "type": "DATABASE_ERROR"  # Tipo de error único
                    }

                if not update_result.modified_count > 0:
                    return {
                        "info": "Error al programar la cita en la base de datos.",
                        "status": "no",
                        "type": "DATABASE_ERROR"  # Tipo de error único
                    }

                print('reservo')
                return {
                    "info": f"Cita confirmada para {professional} desde {start_time} hasta {end_time}.",
                    "status": "ok",
                    "type": "SUCCESS",  # Tipo de error único
                    "data": {
                        "id_appointment": id_appointment
                    }
                }
            else:
               
                return {
                    "info": f"No hay disponibilidad para {professional} en el horario solicitado.",
                    "status": "no",
                    "type": "NO_AVAILABILITY"  # Tipo de error único
                }
            
        except Exception as e:
            self.response = {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "UNKNOW_ERROR"
            }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/config.py
from datetime import datetime

config = {
    "morning_opening_time": datetime.strptime("09:00", '%H:%M'),
    "morning_closing_time": datetime.strptime("13:30", '%H:%M'),
    "afternoon_opening_time": datetime.strptime("15:00", '%H:%M'),
    "afternoon_closing_time": datetime.strptime("20:00", '%H:%M')
}

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/booking/remove.py

from pydantic import BaseModel
from datetime import datetime, timedelta
from .config import config
import numba as nb
from abc import ABC, abstractmethod
from crud.mongodb.users.booking.remove import RemoveBookingUser
from Backend.microservices.app.API.v1.db.mongodb.database import users, reservas


class Verify(ABC):
    @abstractmethod
    def remove(self) -> dict:
        pass


class  RemoveBooking(Verify):

    class structure(BaseModel):
        day: int
        month: int
        year: int
        professional: str
        period: str
        start_time: str
        service_duration: timedelta
        person_id: str
        service_name: str
        id_appointment: str



    #@nb.jit(nopython=True)
    def __init__(self, data_raw: structure) -> None:
        self.response = None
        try:
            data = data_raw.model_dump()
            self.response = self.remove(
                day= data["day"],
                month= data["month"],
                year= data["year"],
                professional= data["professional"],
                period= data["period"],
                start_time= data["start_time"],
                service_duration= data["service_duration"],
                person_id= data["person_id"],
                service_name= data["service_name"], 
                id_appointment= data["id_appointment"]
            )
        except Exception as e:
            self.response = {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "UNKNOW_ERROR"
            }

    #@nb.jit(nopython=True)
    def remove(self, day, month, year, professional, period, start_time, service_duration, person_id, service_name, id_appointment) -> dict:
        start_time_dt = datetime.strptime(start_time, '%H:%M')  # Convertir start_time a datetime
        #print('aqui?')
        try:
            #print(year, month, day)
            day_date = datetime(year, month, day)
            day_appointment = reservas.find_one({"fecha": {"$eq": day_date}})
            #print('day_appointment ->', day_appointment)
            professionals = day_appointment.get('professionals')
        except Exception as e:
            return {
                "info": f"Error al acceder a la base de datos: {e}",
                "status": "no",
                "type": "DATABASE_ERROR"
            }

        #print('alla')
        morning_opening_time = config["morning_opening_time"]
        morning_closing_time = config["morning_closing_time"]
        afternoon_opening_time = config["afternoon_opening_time"]
        afternoon_closing_time = config["afternoon_closing_time"]
        #print('asa')
        if period == 'morning':
            if start_time_dt < morning_opening_time or start_time_dt >= morning_closing_time:
                return {
                    "info": "No se puede cancelar una cita en la mañana fuera del horario de apertura y cierre.",
                    "status": "no",
                    "type": "OUT_BOOKING"
                }
        elif period == 'afternoon':
            if start_time_dt < afternoon_opening_time or start_time_dt >= afternoon_closing_time:
                return {
                    "info": "No se puede cancelar una cita en la tarde fuera del horario de apertura y cierre.",
                    "status": "no",
                    "type": "OUT_BOOKING"
                }
        #print('llega aqui')
        #print(professionals[professional][period])
        
        if start_time in professionals[professional][period]:
            
            #print(professionals[professional][period][start_time])
            
            #Recorrer por cada franja de horario que tiene el personal y verifica si tiene info, si lo tiene es porque hay una cita reservada
            if "info" in professionals[professional][period][start_time]:
                info = professionals[professional][period][start_time]["info"]

                #Verifica si el servicio coincide con el usuario hecho
                if info["service"] == service_name and info["person_id"] == person_id:
                    start_datetime = datetime.strptime(start_time, '%H:%M')
                    end_datetime = start_datetime + service_duration

                    # Añadimos 30 minutos adicionales al tiempo de finalización
                    end_datetime_plus_half_hour = end_datetime + timedelta(minutes=30)

                    # Marcar todas las franjas horarias asociadas a la cita como "libres"
                    while start_datetime < end_datetime_plus_half_hour:
                        current_time = start_datetime.strftime('%H:%M')
                        #print(current_time)
                        professionals[professional][period][current_time].pop("info", None)  # Remover la información de la cita
                        professionals[professional][period][current_time]["status"] = 'libre'
                        start_datetime += timedelta(minutes=30)

                    #print(professionals)

                    # Verifica si intenta cancelar la cita  antes de los 3 días de realizarlo
                    # Code...
                    

                    # Actualizar el documento en la base de datos
                    update_result = reservas.update_one(
                        {"fecha": {"$eq": day_date}},
                        {"$set": {"professionals": professionals}}
                    )

                    userRemoveAppointment = RemoveBookingUser(
                        RemoveBookingUser.structure(
                            id_appointment=id_appointment,
                            person_id=person_id
                        )
                        
                    )

                    if not userRemoveAppointment.response["status"] == 'ok':
                        #print('pasa algo en la db user remove')
                        return userRemoveAppointment.response
                    
                    

                    if update_result.modified_count > 0:
                        # El tipo de error es "SUCCESS" indicando que la operación se realizó correctamente
                        return {"info": f"Cita cancelada para {professional} desde {start_time} hasta {end_datetime.strftime('%H:%M')}.", "status": "ok", "type": "SUCCESS"}
                    else:
                        # El tipo de error es "DATABASE_ERROR" indicando que hubo un error al actualizar la base de datos
                        return {"info": "Error al cancelar la cita en la base de datos.", "status": "no", "type": "DATABASE_ERROR"}
                else:
                    # El tipo de error es "MISMATCH" indicando que los detalles de la cita no coinciden
                    return {"info": "No se puede cancelar la cita porque los detalles de la cita no coinciden.", "status": "no", "type": "MISMATCH"}
            else:
                # El tipo de error es "NO_APPOINTMENT" indicando que no hay una cita programada en el horario especificado
                return {"info": f"No hay una cita programada para {professional} a las {start_time}.", "status": "no", "type": "NO_APPOINTMENT"}
        return {"info": f"No hay disponibilidad para {professional} en el horario solicitado.", "status": "no", "type": "NO_AVAILABILITY"}

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/booking/add.py
#-> ChatGPT debera de comprobar si el codigo sin protección esta bien para hacerse uso

from Backend.microservices.app.API.v1.db.mongodb.database import users
from pydantic import BaseModel, EmailStr
from pydantic import ValidationError
from bson import ObjectId
import datetime
from datetime import datetime
import numba as nb

class AddAppointment(BaseModel):
    day: int
    month: int
    year: int
    responsable_appointment: str
    id_appointment: str
    period: str
    start_time: str
    person_id: str
    service: str

class AddBookingUser:

    '''
    '''

    


    #@nb.jit(nopython=True)
    def __init__(self, data_raw: AddAppointment) -> None:
        self.response = {}

        data = data_raw.model_dump()

        responsable_appointment = data["responsable_appointment"]
        id_appointment = data["id_appointment"]
        period = data["period"]
        start_time = data["start_time"]
        person_id = data["person_id"]
        service = data["service"]
        day_date = data["day"]
        month_date = data["month"]
        year_date = data["year"]

        day = datetime(
            year_date,
            month_date,
            day_date
        )

        # Encuentra al usuario
        user = users.find_one({ "_id": ObjectId(person_id) })

        if user:
            # Define los datos de la reserva
            booking_data = {
                "service": service,
                "period": period,
                "start_time": start_time,
                "responsable_appointment": responsable_appointment,
                "date_appointment": day
            }

            # Actualiza el usuario con la nueva reserva
            update_result = users.update_one(
                { "_id": ObjectId(person_id) },
                { "$set": { f"data.reservas.{id_appointment}": booking_data } }
            )

            if update_result.modified_count > 0:
                self.response = {
                    "info": f"Reserva agregada al usuario {person_id}.",
                    "status": "ok",
                    "type": "SUCCESS"  # Tipo de éxito
                }
            else:
                self.response = {
                    "info": "Error al agregar reserva al usuario.",
                    "status": "no",
                    "type": "DATABASE_ERROR"  # Tipo de error de base de datos
                }
        else:
            self.response = {
                "info": "Usuario no encontrado en la base de datos.",
                "status": "no",
                "type": "DATABASE_ERROR"  # Tipo de error de base de datos
            }  


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/booking/remove.py
from Backend.microservices.app.API.v1.db.mongodb.database import users
from pydantic import BaseModel, EmailStr
from bson import ObjectId
import numba as nb

class RemoveBookingUser:
    class structure(BaseModel):
        id_appointment: str
        person_id: str

    #@nb.jit(nopython=True)
    def __init__(self, data_raw: structure) -> None:
        self.response = None

        data = data_raw.model_dump()
        id_appointment = data["id_appointment"]
        person_id = data["person_id"]

        try:
            user = users.find_one({ "_id": ObjectId(person_id) })
            if not user:
                self.response = {
                    "info": f"No se encontró el usuario con ID {person_id}.",
                    "status": "no",
                    "type": "USER_NOT_FOUND"
                }
                return

            reservation = user.get("data", {}).get("reservas", {}).get(id_appointment)
            if not reservation:
                self.response = {
                    "info": f"No se encontró la reserva con ID {id_appointment} en el usuario con ID {person_id}.",
                    "status": "no",
                    "type": "NOT_FOUND_APPOINTMENT"
                }
                return

            update_result = users.update_one(
                { "_id": ObjectId(person_id) },
                { "$unset": { f"data.reservas.{id_appointment}": "" } }
            )

            if update_result.modified_count > 0:
                self.response = {
                    "info": f"Se eliminó correctamente la reserva con ID {id_appointment} del usuario con ID {person_id}.",
                    "status": "ok",
                    "type": "SUCCESS"
                }
            else:
                self.response = {
                    "info": f"No se pudo eliminar la reserva con ID {id_appointment} del usuario con ID {person_id}.",
                    "status": "no",
                    "type": "ERROR_REMOVE_APPOINTMENT"
                }

        except Exception as e:
            self.response = {
                "info": f"Error en la base de datos: {e}",
                "status": "no",
                "type": "DATABASE_ERROR"
            }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/add.py
from pydantic import BaseModel, EmailStr
from pydantic import ValidationError, constr, field_validator
from pydantic_extra_types.phone_numbers import PhoneNumber
from services.secrets_generator.main import secrets_generator
import numba as nb
from typing import Union
from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt
from Backend.microservices.app.API.v1.logging_config import logger

class InfoEncrypted(BaseModel):
    email: constr(max_length=100000)
    password: constr(max_length=100000)

class Info(BaseModel):
    email: EmailStr
    password: constr(max_length=75)

class Secrets(BaseModel):
    jwt: str

class Data(BaseModel):
    reservas: dict
    info: InfoEncrypted
    secrets: Secrets

class Add(BaseModel):
    data: Data

class AddUser:

    '''
    Se define el esquema Info, solo para añadir los datos necesarios
    al crear el usuario, y como ya esté creado, lo otro no lo hará
    uso hasta que haga otras acciones.

    El password tiene un máximo de 75 caracteres
    '''

    def __init__(self, info: Info):
        
        logger.info("Entra a AddUser")

        email: EmailStr = info["email"]
        password: str = info["password"]

        # Cifrar el email y el password
        encrypted_email = encrypt(email)
        encrypted_password = encrypt(password)
        
        logger.info(f"encrypted_email: {encrypted_email}")
        logger.info(f"encrypted_password: {encrypted_password}")

        # Crear el objeto Info, y verifica los atributos esten bien hechos. Como la verificación del email y el password
        Info(**{
            "email": email,
            "password": password
        })

        encrypted_info = InfoEncrypted(**{
            "email": encrypted_email,
            "password": encrypted_password
        })
        logger.info(f"encrypted_info: {encrypted_info}")

        # Crear el JWT cifrado
        jwt_token = encrypt(str(secrets_generator(120)))
        
        self.data = {
            "data": {
                "reservas": {},
                "info": encrypted_info,
                "secrets": {
                    "jwt": jwt_token
                }
            }
        }

        logger.info("data to send: %s", self.data)

        self.response = None

        try:
            self.user_validated = self.verify(self.data)

            self.aggregate(self.user_validated)
            self.response = {"status": "ok"}

        except AttributeError as e:
            logger.error("Error a la hora de insertar el usuario INVALID_DATA: %s", e)
            self.response = {
                "info": f"El atributo no se encontró: {e}",
                "status": "no",
                "type": "INVALID_DATA"
            }
        except ValidationError as e:
            logger.error("Error a la hora de insertar el usuario VALIDATION_ERROR: %s", e)
            self.response = {
                "info": f"Al validar los datos hubo un error: {e}",
                "status": "no",
                "type": "VALIDATION_ERROR"
            }
        except Exception as e:
            self.response = {
                "info": str(e),
                "status": "no",
                "type": "UNKNOW_ERROR"
            }

    def verify(self, data: dict):
        user = Add(**data)
        return user.model_dump()

    def aggregate(self, user_validate):
        try:
            logger.info("USERVALDIATE: %s", user_validate)
            users.insert_one(user_validate)

        except Exception as e:
            logger.error("Error a la hora de insertar el usuario: %s", e)
            self.response = {
                "info": str(e),
                "status": "no",
                "type": "DATABASE_ERROR"
            }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/delete.py

from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.logging_config import logger
from pydantic import BaseModel
from bson import ObjectId
import numba as nb
import pymongo.errors

class UserDelete:
    
    '''
    Se encarga de eliminar el usuario de forma compelta, pero claro 
    veríficara si tiene reservas pendientes y si tiene no podra borrar
    el usuario. Necesitara antes borrar de forma verificada cada reserva
    a aprtir de la ruta de /app/api/v1/client/restricted/booking/remove
    y la ruta que hará el delete se encargara antes de borrar en el
    usuario borrar y verificar que se puedan borrar las reservas. Quizás
    el usuario quiera borrar la cuenta por que no quiere asssistir en
    la reserva, pero no tenga la opción de poder eliminar la cuenta. Por
    tener una reserva pendiente.
    '''

    class structure(BaseModel):
        user_id: str
    
    #@nb.jit(nopython=True)
    def __init__(self, raw_data: structure) -> None:
        raw_data = raw_data.model_dump()
        user_id = raw_data["user_id"]

        self.response = self.remove(user_id)

    #@nb.jit(nopython=True)
    def remove(self, user_id):
        
        #Obtiene las reservas y luego verifica si no hay ningúna
        reservas = users.find_one({ "_id": ObjectId(user_id) }, { "_id": 0, "data.reservas": 1 })
        logger.info(reservas)
        logger.info(len(reservas) == 0)


        # Si no hay alguna reserva devolver que no debería tener
        if not reservas:
            print('Existen reservas.')
            return {
                "info": "Exiten reservas pendientes a verificar, no se puede eliminar la cuenta",
                "status": "no",
                "type": "APPOINTMENTS_EXISTENTS"
            }
        
        # Si no hay reservas pendientes a verificar, se eliminará la cuenta del usuario
        try:
            print('Como no existen reservas comienza a eliminar la cuenta.')
            users.delete_one({ "_id": ObjectId(user_id) })
        except Exception as e:
            return {
                "info": f"Error al eliminar la cuenta completa: {e}",
                "status": "no",
                "type": "DATABASE_ERROR"
            }
        
        print('Todo salió bien, se eliminó la cuenta exitosamente.')
        return {
            "info": "Se eliminó la cuenta de forma correcta",
            "status": "ok",
            "type": "SUCCESS"
        }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/find.py
from pydantic import BaseModel, EmailStr
from pydantic import ValidationError
from bson import ObjectId
from typing import Union
import numba as nb
from .validation import ValidationUser
from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt

class Find(BaseModel):
    email: EmailStr

global FindSecretJWTCredentials
class FindSecretJWTCredentials(BaseModel):
    email: EmailStr
    password: str
        
global FindSecretJWTID
class FindSecretJWTID(BaseModel):
    id: str


class FindUser:
    class info:

        #@nb.jit(nopython=True)
        def __init__(self, find: Find) -> None:
            self.email = find.email
            self.encrypted_email: bytes = encrypt(self.email)

            try:
                self.found = users.find_one({
                    "data.info.email": self.encrypted_email
                })

                if self.found:
                    self.response = {
                        "info": f"Se encontró un usuario con el email: {self.email}",
                        "status": "no",
                        "type": "FOUND_USER"
                    }
                else:
                    self.response = {
                        "info": f"No se encontró ningún usuario con el email: {self.email}",
                        "status": "no",
                        "type": "NO_FOUND_USER"
                    }
            except AttributeError as e:
                self.response = {
                    "info": str(e),
                    "status": "no",
                    "type": "ATTRIBUTE_ERROR"
                }
            except Exception as e:
                self.response = {
                    "info": str(e),
                    "status": "no",
                    "type": "UNKNOWN_ERROR"
                }

    class secret_jwt:
        
        #@nb.jit(nopython=True)
        def __init__(self, data: Union[FindSecretJWTCredentials, FindSecretJWTID]):
            self.response = None

            
            
            if isinstance(data, FindSecretJWTCredentials):

                data = data.model_dump()
                #print(data)
                try:
                    user_validate = ValidationUser({
                        "email": data.email,
                        "password": data.password
                    })

                    if user_validate.response["status"] == 'ok':
                        user_id = user_validate.response["data"]
                        user = users.find_one({ "_id":  ObjectId(user_id)})
                        jwt = user["data"]["info"]["secrets"]["jwt"]
                        if user:
                            if jwt:
                                self.response = {
                                    "info": "JWT secret obtenido exitosamente",
                                    "status": "ok",
                                    "type": "SUCCESS",
                                    "data": jwt
                                }
                            else:
                                self.response = {
                                    "info": "No se encontró el JWT secret para el usuario",
                                    "status": "error",
                                    "type": "JWT_SECRET_NOT_FOUND"
                                }
                        else: 
                            self.response = {
                                "info": "Usuario no encontrado",
                                "status": "no",
                                "type": "USER_NOT_FOUND"
                            }
                    else:
                        self.response = user_validate.response
                except Exception as e:
                    self.response = {
                        "info": str(e),
                        "status": "no",
                        "type": "UNKNOWN_ERROR"
                    }
            elif isinstance(data, FindSecretJWTID):
                
                data = data.model_dump()
                try:
                    print(data)
                    user = users.find_one({"_id": ObjectId(data["id"])})
                    print(user)

                    if user:
                        try:
                            secret = user["data"]["secrets"]["jwt"]
                            self.response = {
                                "info": "Se encontró la clave privada del usuario para el JWT",
                                "status": "ok",
                                "type": "SUCCESS",
                                "data": secret
                            }
                        except KeyError:
                            self.response = {
                                "info": "El atributo secret del usuario en la base de datos no se encuentra",
                                "status": "no",
                                "type": "NOT_FOUND_SECRET_JWT"
                            }
                    else:
                        self.response = {
                            "info": "El usuario no se encontró",
                            "status": "no",
                            "type": "USER_NOT_FOUND"
                        }
                except Exception as e:
                    self.response = {
                        "info": str(e),
                        "status": "no",
                        "type": "UNKNOWN_ERROR"
                    }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/update.py
from pydantic import BaseModel, EmailStr
from pydantic import ValidationError
from services.secrets_generator.main import secrets_generator
from bson import ObjectId
import numba as nb
from abc import ABC, abstractmethod

from .validation import ValidationUser
from services.auth import JWToken
from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt
from Backend.microservices.app.API.v1.logging_config import logger

'''
Aquí estaran todos los métodos que se haran uso, estan de forma controlada
para que no se puedan modificar cualquier dato que nos de la gana.
Para evitar fallos de seguirdad

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpbmZvIjp7ImVtYWlsIjoiYWRyaWFuZWxjYXBvQGdtYWlsLmNvbSIsInBhc3N3b3JkIjoiZnVja195b3UifSwiZXhwIjoxNzE1NjI3Nzk2fQ.fTxdy_7X63-ypQnYib42HMYQ2_Zwa3o16BvBTwsugjI
'''

class Verify(ABC):

    class PasswordUpdate(BaseModel):
        pass

    class SecretJWTUpdate(BaseModel):
        pass

    class secret_jwt:
        def __init__(self, data) -> None:
            pass

    class password:
        def __init__(self) -> None:
            pass

        def change_password(self, data):
            pass


class UpdateUser(Verify):

    global PasswordUpdate
    global SecretJWTUpdate

    class PasswordUpdate(BaseModel):
        email: EmailStr
        password: str
        new_password: str
    
    class SecretJWTUpdate(BaseModel):
        email: EmailStr
        password: str

    class secret_jwt:

        #@nb.jit(nopython=True)
        def __init__(self, data: SecretJWTUpdate) -> None:
            
            '''
            Valida el usurio y si existe, y si existe crea una nueva clave jwt secreta para el
            usuario, lo guarda en el db y le da al usuario el "token_data" encriptado con su clave secreta

            Structure: {
                email: "example@gmail.com",
                password: "example"
            }

            Types of errors: 
            - UNKNOWN_ERROR
            - SubErrors:
                - ValidationUser()
                - JWToken.create()
            

            Response: {
                "info": "Clave cambiada correctamente y jwt creado correctamente",
                "status": "ok",
                "type": "SUCCESS",
                "data": {
                    "token": jwt
                } 
            }
            '''

            try:
                email: str = data["email"]
                password: str = data["password"]
                #print('1-> update jwt', data)

                validation_user = ValidationUser({
                    "email": email,
                    "password": password,
                    "info": False
                })

                logger.info("validation_user: %s", validation_user)
                #print('2-> update jwt', validation_user)

                #Si el usuario esta de la forma correcta añadera el secreto de jwt en su profile
                if validation_user.response["status"] == "ok":
                    
                    #Genera el secreto
                    secret = str(secrets_generator(120))
                    encrypted_secret_key = encrypt(secret)
                    #print('3-> update jwt', secret)
                    #print('secret ->', secret) 
                    #print('_id ->', validation_user.response["data"]) #<- Posible Error

                    user_id = validation_user.response["data"]
                    #print('4-> update jwt', user_id)

                    users.update_one(
                        { "_id": ObjectId(user_id) },
                        { "$set": {"data.secrets.jwt": encrypted_secret_key} }
                    )

                    jwt = JWToken.create({
                        "email": data["email"],
                        "password": data["password"]
                    }, secret)

                    #print('5-> update jwt', jwt)

                    if jwt["status"] == 'ok':
                        self.response = {
                            "info": "Clave cambiada correctamente y jwt creado correctamente",
                            "status": "ok",
                            "type": "SUCCESS",
                            "data": {
                                #Devuelve el token_data, no el token_id
                                "token": jwt["token"]
                            } 
                        }
                    else:
                        self.response = jwt
                else:
                    self.response = validation_user.response


            except Exception as e:
                logger.info("Hubo un error inesperado: %s", e)
                self.response = {
                    "info": str(e),
                    "status": "no",
                    "type": "UNKNOWN_ERROR"
                }

    class password:

        #@nb.jit(nopython=True)
        def __init__(self, data: PasswordUpdate):
            try:
                self.response = None
                self.change_password(data)
            except Exception as e:
                self.response = {
                    "info": str(e),
                    "status": "no",
                    "type": "UNKNOWN_ERROR"
                }

        #@nb.jit(nopython=True)
        def change_password(self, data):

            validation_user = ValidationUser({
                "email": data["email"],
                "password": data["password"]
            })

            #print('1->', validation_user.response)

            if validation_user.response["status"] == "ok":

                user_id = validation_user.response["data"]

                new_password: str = data["new_password"]
                encrypted_new_password: str = encrypt(new_password)

                #print('2->', user_id)
                #print('pasw ->', data["new_password"])
                # Actualizar la contraseña en la base de datos usando el ID del usuario
                users.update_one(
                    {"_id": ObjectId(user_id)},
                    {"$set": {"data.info.password": encrypted_new_password}}
                )
                self.response = {
                    "info": "Password updated successfully.",
                    "status": "ok",
                    "type": "PASSWORD_UPDATED"
                }
            else:
                #print('3-> Faildes update password')
                self.response = {
                    "info": "Failed to update password.",
                    "status": "no",
                    "type": "PASSWORD_UPDATE_FAILED"
                }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/mongodb/users/validation.py
from pydantic import BaseModel, EmailStr
import numba as nb
from Backend.microservices.app.API.v1.db.mongodb.database import users
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt

class Credentials(BaseModel):
    email: EmailStr
    password: str
    info: bool = False


class ValidationUser:

    #@nb.jit(nopython=True)
    def __init__(self, data: Credentials):
        '''
        Validar si el usuario exite, si existe, devolver el id del db

        Structure: {
            email: "example@gmail.com",
            password: "example",
            info: (Default: False)
        }

        What is info?:
        - Info refers if you want more data and return the all information of the user, but if you dont want the all data, you can give the id user in the db 

        Types of errors: 
        - UNKNOWN_ERROR
        - USER_NOT_FOUND
        - INCORRECT_PASSWORD
        - DATABASE_ERROR

        Response: {
            "info": "Password validation successful.",
            "status": "ok",
            "type": "PASSWORD_VALIDATED",
            "data": "id_database" / user_document
        }

        How to access:
        - user = Validation()
        - [ user.response ] 
        '''
        try:
            self.response = None
            self.search_user(data)
        except Exception as e:
            self.response = {
                "info": str(e),
                "status": "no",
                "type": "UNKNOWN_ERROR"
            }

    #@nb.jit(nopython=True)
    def search_user(self, data):
        #print('comienza por aqui')
        
        email: str = data["email"]
        encrypted_email: bytes = encrypt(email)

        user = users.find_one({
            "data.info.email": encrypted_email
        })
        #print('user -> ', user)
        if user:
            self.validate_password(user, data)
        else:
            #print('here?)')
            self.response = {
                "info": "User not found.",
                "status": "no",
                "type": "USER_NOT_FOUND"
            }

    #@nb.jit(nopython=True)
    def validate_password(self, user, data):

        mongodb_user_password: str = decrypt(user["data"]["info"]["password"])
        query_client_password: str = data["password"]

        try:
            if mongodb_user_password == query_client_password:
                
                if data["info"] != False:
                    self.data = dict(user)
                else:
                    self.data = str(user["_id"])

                self.response = {
                    "info": "Password validation successful.",
                    "status": "ok",
                    "type": "PASSWORD_VALIDATED",
                    "data": self.data
                }
            else:
                self.response = {
                    "info": "Incorrect password.",
                    "status": "no",
                    "type": "INCORRECT_PASSWORD"
                }
        except Exception as e:
            #print('here?')
                    # Capturar y manejar el error de la base de datos
            self.response = {
                "info": "Database error: " + str(e),
                "status": "no",
                "type": "DATABASE_ERROR"
            }

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/rethink_db/booking/add.py
from pydantic import BaseModel, constr
from abc import ABC, abstractmethod
from datetime import datetime
from uuid import uuid4
from Backend.microservices.app.API.v1.logging_config import logger
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection


class Verify(ABC):

    class structure(BaseModel):
        pass

    @abstractmethod
    def __init__(self) -> None:
        pass
    
    @abstractmethod
    def add_booking(self) -> dict:
        pass

class AddBooking(Verify):
    """
    Crea reservas no verificadas en RethinkDB.
    """

    class structure(BaseModel):
        user: constr(max_length=500)
        date: datetime
        hour: constr(max_length=10)
        id_appointment: constr(max_length=50)
        personal_type: constr(max_length=50)
        personal_id: constr(max_length=50)

    def __init__(self, data_raw: structure) -> None:
        data: dict = data_raw.model_dump()  # Cambiado de model_dump() a dict()
        
        logger.info(f"Data -> {data}")

        self.date: datetime = data["date"]
        self.personal_type: str = data["personal_type"]
        self.personal_id: str = data["personal_id"]
        self.user: str = data["user"]
        self.hour: str = data["hour"]
        self.id_appointment: str = data["id_appointment"]

        try:
            self.response = self.add_booking()
        except Exception as e:
            self.response = {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "UNKNOWN_ERROR"
            }

    def add_booking(self) -> dict:
        try:
            request: dict = {
                "user": self.user,
                "hour": self.hour
            }

            # Formatear la fecha como ISO 8601 para la base de datos
            formatted_date: datetime.isoformat = self.date.isoformat()
            
            logger.info(f"Fecha: {formatted_date}")
            # Buscar el documento por un identificador único (ej. fecha)
            cursor = reservas.filter({"fecha": formatted_date}).run(connection)
            sheet_list = list(cursor)  # Convertir el cursor a una lista

            if not sheet_list:
                return {
                    "info": "No se encontró la reserva para actualizar.",
                    "status": "no",
                    "type": "NOT_FOUND"
                }

            sheet_id = sheet_list[0]['id']  # Asumiendo que el id es un campo en el documento

            # Actualizar el documento usando la clave dinámica
            reservas.get(sheet_id).update({
                "professionals": { 
                    str(self.personal_type): {
                        str(self.personal_id): {
                            str(self.id_appointment): request
                        }
                    }
                }
            }).run(connection)

            return {
                "info": "Cita añadida en la base de datos en tiempo real",
                "status": "ok",
                "type": "SUCCESS"
            }

        except Exception as e:
            return {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "RETHINK_DB_DATABASE_ERROR"
            }

if __name__ == "__main__":
    data: dict = {
        "user": "john_doe",
        "date": datetime(2024, 12, 9),
        "hour": "10:00 AM",
        "id_appointment": str(uuid4()),
        "personal_type": "peluqueros",
        "personal_id": "peluquero_2"
    }

    booking_data: AddBooking.structure = AddBooking.structure(**data)
    booking: AddBooking = AddBooking(booking_data)

    print(booking.response)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/crud/rethink_db/booking/remove.py

from pydantic import BaseModel, constr
from abc import ABC, abstractmethod
from datetime import datetime
from rethinkdb import r, net
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection

class Verify(ABC):

    class structure(BaseModel):
        pass

    @abstractmethod
    def __init__(self) -> None:
        pass

    @abstractmethod
    def remove_booking(self) -> dict:
        pass

class RemoveBooking(Verify):
    """
    Quita reservas no verificadas en RethinkDB

    Args:
        Verify ([type]): ABS Class
    """

    class structure(BaseModel):
        date: datetime
        appointment_id: constr(max_length=50)
        personal_type: constr(max_length=200)
        personal_id: constr(max_length=200)

    def __init__(self, data_raw: structure) -> None:
        self.response = {}

        data: dict = data_raw.model_dump()
        self.date: datetime = data["date"]
        self.personal_type: str = data["personal_type"]
        self.personal_id: str = data["personal_id"]
        self.appointment_id: str = data["appointment_id"]

        try:
            self.response = self.remove_booking()
        except Exception as e:
            self.response = {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "UNKNOWN_ERROR"
            }

    def remove_booking(self) -> dict:
        try:
            # Formatear la fecha como ISO 8601 para la base de datos
            formatted_date: datetime.isoformat = self.date.isoformat()

            # Obtener el documento actual
            cursor: net.DefaultCursor = reservas.filter({"fecha": formatted_date}).run(connection)
            sheet_list: list = list(cursor)

            if not sheet_list:
                return {
                    "info": "No se encontró la reserva para actualizar.",
                    "status": "no",
                    "type": "NOT_FOUND"
                }

            sheet_id: str = sheet_list[0]['id']
            document = sheet_list[0]  # Obtener el documento

            # Eliminar el appointment_id del documento en Python
            try:
                del document['professionals'][self.personal_type][self.personal_id][self.appointment_id]
            except KeyError:
                return {
                    "info": "No se encontró la cita en la estructura.",
                    "status": "no",
                    "type": "APPOINTMENT_NOT_FOUND"
                }

            # Actualizar el documento en la base de datos
            reservas.get(sheet_id).replace(document).run(connection)

            return {
                "info": "Se quitó la cita en la base de datos en tiempo real",
                "status": "ok",
                "type": "SUCCESS"
            }

        except Exception as e:
            return {
                "info": f"Error desconocido del servidor: {e}",
                "status": "no",
                "type": "RETHINK_DB_DATABASE_ERROR"
            }

if __name__ == "__main__":
    data: dict = {
        "date": datetime(2024, 12, 9),
        "personal_id": "peluquero_2",
        "personal_type": "peluqueros",
        "appointment_id": "84dc0ae9-368d-4e82-9939-c1ddbb5a8c12"
    }

    booking_data: RemoveBooking.structure = RemoveBooking.structure(**data)
    booking: RemoveBooking = RemoveBooking(booking_data)

    print(booking.response)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/CryptoAPI/main.py
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt

import random
import string
import time



if __name__ == "__main__":

    # Generar la cadena aleatoria
    random_string: str = ''.join(random.choices(string.ascii_letters, k=10))
    
    text: str = random_string
    del random_string

    start_time = time.time()

    encrypted_text: bytes = encrypt(text)
    #print(encrypted_text)

    decrypted_text: str = decrypt(text.encode()).decode()
    #print(decrypted_text)

    end_time = time.time()
    print(f'Execution time: {end_time - start_time}')

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/mongodb/services/delete_all_appointments.py
from typing import Any
from pydantic import BaseModel
from abc import abstractmethod, ABC
from typing import Union
from Backend.microservices.app.API.v1.db.mongodb.database import reservas


class Verify(ABC):
    
    @abstractmethod
    def __call__(self) -> int:
        pass

    @abstractmethod
    def delete_appointments(self) -> None:
        pass



class RemoveAllAppointments(Verify):

    def __call__(self) -> int:
        return self.delete_appointments()

    def delete_appointments(self) -> Union[int, Exception]:

        """
        Elimina todas las fichas de reserva del db.
        """
        return reservas.delete_many({})


if __name__ == "__main__":

    remove_all: None = RemoveAllAppointments()
    remove_all()

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/mongodb/services/make_all_appointment_sheet.py
from datetime import datetime, timedelta
from pymongo import DESCENDING
from uuid import uuid4
from pydantic import BaseModel
from numpy import ushort
from abc import ABC, abstractmethod
from typing import Dict
import json
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, personal
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas as RDBreservas, connection as RDBconnection
from Backend.microservices.app.API.v1.logging_config import logger





class ProfesionalsStructure:

    class generar_horarios(BaseModel):
        start_time_morning: str
        end_time_morning: str
        start_time_afternoon: str
        end_time_afternoon: str
    
    class generar_diccionario_profesionales(BaseModel):
        start_time_morning: str
        end_time_morning: str
        start_time_afternoon: str
        end_time_afternoon: str


class Verify_profesionals(ABC):
    
    @abstractmethod
    def generar_horarios(
        cls,
        data_raw: ProfesionalsStructure.generar_horarios
    ) -> dict:
        pass

    @abstractmethod
    def generar_diccionario_profesionales(
        cls,
        data_raw: ProfesionalsStructure.generar_diccionario_profesionales
        ) -> dict:
        pass


class Profesionals(Verify_profesionals):

    @classmethod
    def generar_horarios(cls, data_raw: ProfesionalsStructure.generar_horarios) -> dict:
        """
        Se require de 2 variables de las horas en formato 24 horas.
        Genera los horarios a partir de diferentes horarios
        de mañana y por la tarde, creando llaves en un diccionario
        de esos horarios entre 30' en cada horario.
        """
        try:
            # Desestructuración de datos validados
            data: dict = data_raw.model_dump()

            start_time_morning: str = data["start_time_morning"]
            end_time_morning: str = data["end_time_morning"]
            start_time_afternoon: str = data["start_time_afternoon"]
            end_time_afternoon: str = data["end_time_afternoon"]

            logger.info(f"{start_time_morning}")
            logger.info(f"{end_time_morning}")
            logger.info(f"{start_time_afternoon}")
            logger.info(f"{end_time_afternoon}")

            # Diccionario principal
            horarios = {}
            horarios["morning"] = {}
            horarios["afternoon"] = {}
            horario_morning = horarios["morning"]
            horario_afternoon = horarios["afternoon"]
            
            # Primer rango: Mañana
            inicio = datetime.strptime(start_time_morning, "%H:%M")
            fin = datetime.strptime(end_time_morning, "%H:%M")
            while inicio <= fin:
                hora_str = inicio.strftime("%H:%M")
                horario_morning[hora_str] = {}  # Diccionario vacío
                horario_morning[hora_str]["status"] = "libre"
                inicio += timedelta(minutes=30)
            
            # Segundo rango: Tarde
            inicio = datetime.strptime(start_time_afternoon, "%H:%M")
            fin = datetime.strptime(end_time_afternoon, "%H:%M")
            while inicio <= fin:
                hora_str = inicio.strftime("%H:%M")
                horario_afternoon[hora_str] = {}  # Diccionario vacío
                horario_afternoon[hora_str]["status"] = "libre"

                inicio += timedelta(minutes=30)
            #logger.info("->>>> %s", horarios)
            return horarios
        except Exception as e:
            logger.error(str(e))
            return {}

    
    @classmethod
    def generar_diccionario_profesionales(cls, data_raw: ProfesionalsStructure.generar_diccionario_profesionales) -> dict:
        """
        Genera un diccionario coherente de los profesionales
        disponibles listo para añadirse en la ficha de reservas
        """
        try:
            #Desestruturaión de datos validados
            data: dict = data_raw.model_dump()
            print(f"\n\ndata2: {data}")

            start_time_morning: str = data["start_time_morning"]
            end_time_morning: str = data["end_time_morning"]
            start_time_afternoon: str = data["start_time_afternoon"]
            end_time_afternoon: str = data["end_time_afternoon"]

            profesionals_proccessed: dict = {}
            profesionals_proccessed["professionals"] = {}
            profesionals_proccessed_professionals = profesionals_proccessed["professionals"]
            logger.info(profesionals_proccessed_professionals)

            hours: dict = cls.generar_horarios(
                data_raw=ProfesionalsStructure.generar_horarios(
                    start_time_morning=     start_time_morning,
                    end_time_morning=       end_time_morning,
                    start_time_afternoon=   start_time_afternoon,
                    end_time_afternoon=     end_time_afternoon
                )
            )

            last_version_personal_raw: dict = personal.find_one(sort=[('_id', DESCENDING)])

            last_version_personal: dict = last_version_personal_raw["personal"]
            
            for type_personal, list_personal in last_version_personal.items():
                
                for id_personal in list_personal:
                    profesionals_proccessed_professionals[id_personal] = hours

            profesionals_proccessed["version"] = last_version_personal_raw["version"]
            return profesionals_proccessed


        except Exception as e:
            logger.error(f"{e}")





class ORMongodbStructure:

    class verify_existent_sheet(BaseModel):
        fecha: datetime

    class generate_all_sheets(BaseModel):
        structure_profesionals_data: Dict
        number_of_sheets: int


class Verify_ORMongodb(ABC):
    
    @abstractmethod
    def verify_existent_sheet(
        cls,
        data_raw: ORMongodbStructure.verify_existent_sheet
    ) -> bool:
        pass

    @abstractmethod
    def generate_all_sheets(
        cls,
        data_raw: ORMongodbStructure.generate_all_sheets
    ) -> None:
        pass


class ORMongodb(Verify_ORMongodb):

    @classmethod
    def verify_existent_sheet(cls, data_raw: ORMongodbStructure.verify_existent_sheet) -> bool:
        """
        Verifica si la ficha de reserva de ese día se creó o no.
        """
        try:
            data: dict = data_raw.model_dump()
            fecha: datetime = data["fecha"]  # Asegúrate de que 'fecha' es un objeto datetime

            if not isinstance(fecha, datetime):
                raise ValueError("Fecha debe ser un objeto datetime")

            # Asegúrate de que la fecha es precisa hasta los segundos
            fecha = fecha.replace(microsecond=0)
            #logger.info(f"Fecha verificada: {fecha} (tipo: {type(fecha)})")

            # Verificar si el documento ya existe en la colección
            result_query: dict | None = reservas.find_one({"fecha": fecha})
            #logger.info(result_query)

            return result_query is not None

        except Exception as e:
            logger.error(str(e))
            return False

    @classmethod
    def generate_all_sheets(cls, data_raw: ORMongodbStructure.generate_all_sheets):
        """
        Genera fichas de reserva a partir de un numero determinado
        de fichas a partir del día que se crean, sumando los días adicionales.
        """
        try:
            data: dict = data_raw.model_dump()
            num_days_ahead: int = data["number_of_sheets"]
            structure_profesionals_data: dict = data["structure_profesionals_data"]

            start_date: datetime = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
            dates: list = [start_date + timedelta(days=i) for i in range(num_days_ahead)]

            for date in dates:
                result_sheet = cls.verify_existent_sheet(
                    ORMongodbStructure.verify_existent_sheet(fecha=date)
                )
                if not result_sheet:
                    structure_profesionals_data["fecha"] = date
                    # Elimina el campo "_id" si existe, para evitar duplicados
                    structure_profesionals_data.pop("_id", None)

                    reservas.insert_one(structure_profesionals_data)

                logger.info(f"Insertando documento para la fecha: {structure_profesionals_data}")
                #logger.info(f"Fecha ({date}): {result_sheet}")

        except Exception as e:
            logger.error(e)
            

if __name__ == "__main__":

    """
    Zona de testeo en desarrollo
    """
    structure_profesionals_data: dict = Profesionals.generar_diccionario_profesionales(
        data_raw=ProfesionalsStructure.generar_diccionario_profesionales(
            start_time_morning="09:00",
            end_time_morning="13:30",
            start_time_afternoon="15:00",
            end_time_afternoon="20:00"
        )
    )
    logger.info(f"{structure_profesionals_data}")

    
    ORMongodb.generate_all_sheets(
        data_raw=ORMongodbStructure.generate_all_sheets(
            structure_profesionals_data=structure_profesionals_data,
            number_of_sheets=120
        )
    )


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/mongodb/create_db.py
#PYMONGO STRUCTURE DATABASE!

from Backend.microservices.conversor.config.config import Config
from Backend.microservices.app.API.v1.db.mongodb.database import client

config = Config()
db_config = config['db']['persistant']['mongodb']

use_db = db_config['db']
collection = db_config['collections']


# Verificar si la base de datos ya existe
if use_db in client.list_database_names():
    print(f'La base de datos {use_db} ya existe.')
else:
    # Crear la base de datos
    db = client[use_db]
    print(f'Base de datos {use_db} creada.')

    # Crear las colecciones en la nueva base de datos
    for coleccion in collection.item():
        db.create_collection(coleccion)
        print(f'Colección {coleccion} creada en la base de datos {use_db}.')
        
# Verificar y notificar si las colecciones ya existen
db = client[use_db]  # Seleccionar la base de datos

for ref, coleccion in collection.items():
    if coleccion in db.list_collection_names():
        print(f'La colección {coleccion} ya existe en la base de datos {use_db}.')
    else:
        db.create_collection(coleccion)
        print(f'Colección {coleccion} creada en la base de datos {use_db}.')

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/mongodb/database.py
import os
from pymongo import MongoClient
from urllib.parse import quote_plus
from Backend.microservices.conversor.config.config import Config

try:
    config: dict = Config()
    db_config: str = config['db']['persistant']['mongodb']
    port: str = db_config['port']
    host: str = db_config['host']
    username: str = db_config['username']
    password: str = db_config['password']
    use_db: str = db_config['db']
    collection: str = db_config['collections']

    use_reservas: str = collection['reservas']
    use_usuarios: str = collection['usuarios']
    use_configuracion: str = collection['configuracion']
    use_personal: str = collection['personal']
    use_administrador: str = collection['administrador']
    use_tipos_de_pydantic: str = collection['tipos_de_pydantic']

    # Codifica el nombre de usuario y la contraseña
    username = quote_plus(username)
    password = quote_plus(password)

    # Verifica las variables de entorno
    username_env = os.getenv('MONGODB_HAIRDRESSER_USERNAME')  # Ajusta si el nombre de variable es diferente
    password_env = os.getenv('MONGODB_HAIRDRESSER_PASSWORD')  # Ajusta si el nombre de variable es diferente

    if username_env:
        username = username_env
    if password_env:
        password = password_env

    if not (username and password):
        raise ValueError("The variables from the environment have not been configured yet")

    # Construye la URL de conexión
    connection_uri = f'mongodb://{username}:{password}@{host}:{port}'
    print(connection_uri)
    
    client = MongoClient(connection_uri)
    db = client[use_db]

    reservas = db[use_reservas]
    users = db[use_usuarios]
    configure = db[use_configuracion]
    personal = db[use_personal]
    admin = db[use_administrador]
    types = db[use_tipos_de_pydantic]

    #count_reservas = reservas.count_documents({})
    #print(f"Conexión exitosa. La colección 'reservas' tiene {count_reservas} documentos.")


except Exception as err:
    print(err)
    raise RuntimeError(f"Have a problem in database.py from API: {err}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/redis_db/database.py
import asyncio
from typing import Optional
from redis.asyncio import Redis
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi_cache import FastAPICache
from fastapi_cache.backends.redis import RedisBackend
from fastapi import FastAPI
from fastapi.responses import JSONResponse
import logging
from abc import ABC, abstractmethod
from Backend.microservices.app.API.v1.logging_config import logger
from Backend.microservices.conversor.config.config import Config

config: dict = Config()
db_config: dict = config["db"]["temporary"]["redis"]
host: str = db_config["host"]
port: int = db_config["port"]
API_db: str = db_config["db"]["microservices"]["app"]["API"]


class Verify(ABC):

    REDIS_URL: str
    _client: Optional[Redis] = None

    @abstractmethod
    async def connect(cls) -> None:
        pass

    @abstractmethod
    async def disconnect(cls) -> None:
        pass

    @abstractmethod
    def get_client(cls) -> Optional[Redis]:
        pass


class RedisClient(Verify):

    # Configuración de Redis
    REDIS_URL: str = f"redis://{host}:{port}/{API_db}"
    
    _client: Optional[Redis] = None

    @classmethod
    async def connect(cls) -> None:
        try:
            cls._client = Redis.from_url(cls.REDIS_URL, encoding="utf-8", decode_responses=True)
            await cls._client.ping()  # Verificar la conexión
            #logger.info(f"Conexión a Redis establecida. URL: {cls.REDIS_URL}")
        except Exception as e:
            cls._client = None
            logger.error(f"Error al conectar a Redis: {e}")

    @classmethod
    async def disconnect(cls) -> None:
        if cls._client:
            await cls._client.close()
            logger.info("Conexión a Redis cerrada.")

    @classmethod
    def get_client(cls) -> Optional[Redis]:
        return cls._client

# Configura y exporta el Limiter
limiter = Limiter(key_func=get_remote_address)

def setup_redis_limiters_and_cache(app: FastAPI):
    redis_client = RedisClient.get_client()
    limiter.storage = redis_client

    FastAPICache.init(RedisBackend(redis_client), prefix="fastapi-cache")

    @app.exception_handler(RateLimitExceeded)
    async def rate_limit_exceeded_handler(request, exc: RateLimitExceeded):
        return JSONResponse(
            status_code=429,
            content={
                "info": "Rate limit exceeded. Please try again later.",
                "status": "no",
                "type": "RATE_LIMIT_ERROR"
            }
        )

    app.state.limiter = limiter

# Exportar el decorador @limiter.limit
rate_limit = limiter.limit


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/services/changes_table.py
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection

cursor = reservas.changes().run(connection)

for change in cursor:
    print("Cambio detectado:")
    print(change)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/services/make_all_appointment_sheet.py
from datetime import datetime, timedelta
from pymongo import DESCENDING
from uuid import uuid4
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, personal
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection

# Esquema de disponibilidad para los próximos 120 días
num_days_ahead = 122
start_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
dates = [(start_date + timedelta(days=i)).isoformat() for i in range(num_days_ahead)]

'''#print(dates)

professionals = {
    "professionals": {
        'peluquero_1': {
            "morning": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(9, 14) for minute in (0, 30)
            },
            "afternoon": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(15, 20) for minute in (0, 30)
            }
        },
        'peluquero_2': {
            "morning": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(9, 14) for minute in (0, 30)
            },
            "afternoon": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(15, 20) for minute in (0, 30)
            }
        },
        'barbero': {
            "morning": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(9, 14) for minute in (0, 30)
            },
            "afternoon": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(15, 20) for minute in (0, 30)
            }
        },
        'esteticista': {
            "morning": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(9, 14) for minute in (0, 30)
            },
            "afternoon": {
                f"{hour:02d}:{minute:02d}": {"status": "libre"} for hour in range(15, 20) for minute in (0, 30)
            }
        },
    },
    "version": "v2"
}
'''
print(start_date.isoformat())

latest_personal: dict = personal.find_one(sort=[('_id', DESCENDING)])
test_json: dict = {}
test_json["professionals"] = {}
json_professionals: dict = test_json["professionals"]

for types_personal in latest_personal["personal"].keys():
    json_professionals[types_personal] = {}

for profesional, staff in latest_personal["personal"].items():

    for person in staff:
        json_professionals[profesional][person] = {}

test_json["version"] = latest_personal["version"]
#test_json["fecha"]: datetime = start_date.isoformat()

#reservas.insert(test_json).run(connection)

fecha_iso: datetime.isoformat = datetime(2024, 8, 20).isoformat()
count_repeted_sheets = reservas.filter({"fecha": fecha_iso}).count().run(connection)

print(count_repeted_sheets == 0)

for date in dates:
    count_repeted_sheets = reservas.filter({"fecha": date}).count().run(connection)

    if count_repeted_sheets == 0:

        test_json["fecha"]: datetime = date
        reservas.insert(test_json).run(connection)
        print(f"New {date}")
    else:
        print(f"Repeated: {date}, Count: {count_repeted_sheets}")

'''fecha_iso: datetime.isoformat = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0).isoformat()
new_data: dict = {
    "greeting.hello": "it works"
}
reservas.filter({"fecha": fecha_iso}).update(new_data).run(connection)
count_repeted_sheets = reservas.filter({"fecha": fecha_iso}).count().run(connection)
'''
print(f"\n{test_json}\n")


print(dates)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/services/make_booking_sheet.py
from datetime import datetime, timedelta
from pymongo import DESCENDING
from uuid import uuid4
from abc import ABC, abstractmethod
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, personal
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection


class Verify(ABC):
    
    @abstractmethod
    def __init__(self) -> None:
        super().__init__()

class BookingSheet(Verify):
    pass


if __name__ == "__main__":

    latest_personal: dict = personal.find_one(sort=[('_id', DESCENDING)])
    test_json: dict = {}
    test_json["professionals"] = {}
    json_professionals: dict = test_json["professionals"]

    for types_personal in latest_personal["personal"].keys():
        json_professionals[types_personal] = {}

    for profesional, staff in latest_personal["personal"].items():

        for person in staff:
            json_professionals[profesional][person] = {}

    test_json["version"] = latest_personal["version"]

    fecha_iso: datetime.isoformat = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0).isoformat()
    count_repeted_sheets = reservas.filter({"fecha": fecha_iso}).count().run(connection)

    if count_repeted_sheets == 0:

        test_json["fecha"] = fecha_iso
        reservas.insert(test_json).run(connection)
    else:
        pass

    print(BookingSheet)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/services/remove_all.py
from typing import Any, Dict
from Backend.microservices.app.API.v1.db.rethink_db.database import reservas, connection

try:
    # Eliminar todos los documentos de la tabla
    result = reservas.delete().run(connection)
    print(f"Documentos eliminados: {result['deleted']}")

except Exception as e:
    print(f"Error al eliminar documentos: {e}")


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/create_db.py
#RETHINKDB STRUCTURE DATABASE!

from Backend.microservices.app.API.v1.db.rethink_db.database import (
    server
    ,r
    ,db_name
    ,db
)
from Backend.microservices.conversor.config.config import Config

config = Config()
list_tables = config['db']['persistant']['rethinkdb']['tables']

# Crear la base de datos principal si no existe
try:
    r.db_create(db_name).run(server)
    print('Base de datos test_db creada.')
except r.errors.ReqlOpFailedError:
    print(f'La base de datos {db_name} ya existe.')


for ref, table in list_tables.items():
    table = str(table)
    try:
        r.table_create(table).run(db)
        print(f'Tabla {table} creada.')
    except r.errors.ReqlOpFailedError:
        print(f'La tabla {table} ya existe.')

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/db/rethink_db/database.py
import rethinkdb as r
from Backend.microservices.conversor.config.config import Config

config = Config()

config_db = config['db']['persistant']['rethinkdb']
port = config_db['port']['client']
host = config_db['host']

reservas = config_db["tables"]["reservas"]

db_name = config_db['db']

try:
    # Conectarse a RethinkDB
    r = r.r
    connection = r.connect(host=host, port=port, db=db_name)
    reservas = r.db(db_name).table(reservas)

    documents = reservas.run(connection)

except Exception as e:

    print(f"Hay un buen problema con RethinkDB: {e}")

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/deployment/docker-compose.yml


services:
  peluqueriamael_app_api:
    #container_name: deployment_peluqueriamael_app_api
    image: peluqueriamael_app_api
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - ../../../../../../Backend:/peluqueriamael/Backend
      - ../../../../../../__init__.py:/peluqueriamael/__init__.py
      - ../../../../../../LICENSE:/peluqueriamael/LICENSE
      - ../../../../../../README.md:/peluqueriamael/README.md
    ports:
      - "8000:8000"
    environment:
      - MONGODB_HAIRDRESSER_PASSWORD=example
      - MONGODB_HAIRDRESSER_USERNAME=root
    command: ['./execute.sh']
    networks:
      - db_hairdresser_network
      - deployment_hairdresser_network_cryptoapi

networks:
  db_hairdresser_network:
    external: true
  deployment_hairdresser_network_cryptoapi:
    external: true

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/deployment/Dockerfile
FROM python:latest  

# Instala las dependencias
RUN pip install pymongo \
    "fastapi-cache2[redis]" \
    pyjwt \
    fastapi \
    gunicorn \
    uvicorn \
    numba \
    pydantic_extra_types \
    phonenumbers \
    sphinx \
    ujson \
    pyyaml \
    pydantic \
    pydantic[email] \
    python-dotenv \
    rethinkdb \
    pytest \
    httpx \
    termcolor \
    validate_utf8 \
    pytest-order \
    redis \
    slowapi




WORKDIR /peluqueriamael/Backend/microservices/app/API/v1


#CMD ["tail", "-f", "/dev/null"]
#CMD ["./execute.sh"]

Backend/microservices/app/API/v1/routes/client/public/main.py
from fastapi import (
    APIRouter,
    Request,
    HTTPException,
    status
)
from fastapi.responses import JSONResponse, Response
from pydantic import ValidationError
from typing import Union
import ujson
from routes.client.schemes.general import schemes
from services.auth import JWToken
from crud.mongodb.users.add import AddUser
from crud.mongodb.users.validation import ValidationUser
from crud.mongodb.users.update import UpdateUser
from crud.mongodb.users.find import FindUser, FindSecretJWTID, Find
from Backend.microservices.app.API.v1.db.redis_db.database import rate_limit
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt
from Backend.microservices.app.API.v1.logging_config import logger

router = APIRouter(prefix="/public")


#Union[Credentials, Token]

@router.options('/login')
async def Loggin_User_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }

@router.post('/login')
#@rate_limit("3/10s")
async def Loggin_User(request: Request, raw_data: schemes.Credentials):

    try:
        data: dict = raw_data.model_dump()

        email: str = data["email"]
        password: str = data["password"]

        # Busca si el usuario ya existe en la base de datos
        existing_user = FindUser.info(Find(email=email))
        
        if existing_user.response["type"] == 'NO_FOUND_USER':
            # Si el usuario ya existe, devuelve un error de usuario existente
            return JSONResponse(existing_user.response, 400)
        
        # Valida al usuario recién agregado
        validation_response = ValidationUser({
            "email": email,
            "password": password,
            "info": False
        })
        #print('validation ->', validation_response.response)

        if validation_response.response["status"] != "ok":
            # Si no se pudo validar al usuario, devuelve un error
            return JSONResponse(validation_response.response, 400)

        # Actualiza el secreto JWT del usuario
        secret_response = UpdateUser.secret_jwt({
            "email": email,
            "password": password,
        })
        #print('aqui bro ->', secret_response.response)

        
        if secret_response.response["status"] != 'ok':
            #print('pasa por aqui bro')
            # Si no se pudo actualizar el secreto JWT, devuelve un error
            return JSONResponse(secret_response.response, 400)

        user_id: str = validation_response.response["data"]
        encrypted_user_id: str = encrypt(user_id)

        # Crea el token JWT para el usuario
        token_id_response = JWToken.create(encrypted_user_id)
        #print('oooo->', token_id_response)

        if token_id_response["status"] != 'ok':
            # Si no se pudo crear el token JWT, devuelve un error
            return JSONResponse(token_id_response, 400)

        #print('<->',token_id_response["token"])
        #print('<->', secret_response.response["data"]["token"])
        # Devuelve la respuesta exitosa con los tokens generados
        return JSONResponse({
            "token_id": token_id_response["token"],
            "token_data": secret_response.response["data"]["token"]
        }, 200)

    except Exception as e:
        return JSONResponse({
            "info": "Error desconocido por el servidor",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "detail": str(e)
        }, 500)


@router.options('/register')
async def Register_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post('/register')
@rate_limit("15/minute")
async def Register_User(request: Request, raw_data: schemes.Credentials):
    '''
    Registra un nuevo usuario.
    *E/D (Encryption/Decryption enabled)
    '''
    try:
        data = raw_data.model_dump()

        email: str = data["email"]
        password: str = data["password"]
        
        #logger.info("Extraccion de validacion de datos hecho")

        # Busca si el usuario ya existe en la base de datos (E/D)
        existing_user = FindUser.info(Find(email=email))
        
        #logger.info("Busqueda del usuario en la base de datos hecha")

        if existing_user.response["type"] == 'FOUND_USER':
            # Si el usuario ya existe, devuelve un error de usuario existente
            return JSONResponse(existing_user.response, 409)
        
        logger.info("Email: %s", data["email"])
        # Agrega el usuario a la base de datos (E/D)
        add_user_response = AddUser({
            "email": email,
            "password": password
        })

        #logger.info("Usuario agregado en la base de datos hecha")
        
        #print(add_user_response.response)

        if add_user_response.response["status"] != 'ok':
            # Si no se pudo agregar el usuario, devuelve un error
            return JSONResponse(add_user_response.response, 400)
        
        # Valida al usuario recién agregado y devuelve _id del usuario (E/D)
        validation_response = ValidationUser({
            "email": email,
            "password": password,
            "info": False
        })

        #logger.info("Valida el usuario recien agregado")

        #print('ValidationUser->', validation_response.response)

        if validation_response.response["status"] != "ok":
            # Si no se pudo validar al usuario, devuelve un error
            #print('pasa por dentro?')
            return JSONResponse(validation_response.response, 400)

        # Actualiza el secreto JWT del usuario (E/D)
        secret_response = UpdateUser.secret_jwt({
            "email": email,
            "password": password,
        })
        #print('secret_response ->', secret_response.response)
        
        if secret_response.response["status"] != 'ok':
            # Si no se pudo actualizar el secreto JWT, devuelve un error
            #print('Esta bien?: ', secret_response.response["status"])
            return JSONResponse(secret_response.response, 400)
        
        #print('pasa por aqui?')
        #logger.info("Actualiza el secreto del usuario")

        user_id: str = validation_response.response["data"]
        #logger.info("validation_response.response[data]: %s", user_id)
        encrypted_user_id: str = encrypt(user_id)

        #.......................................................
        # Crea el token JWT para el usuario
        token_id_response = JWToken.create(encrypted_user_id)
        #print('token_id_response ->', token_id_response)
        #.......................................................

        if token_id_response["status"] != 'ok':
            # Si no se pudo crear el token JWT, devuelve un error
            return JSONResponse(token_id_response, 400)

        #print('acaba respondiendo con un estatus positivo')
        # Devuelve la respuesta exitosa con los tokens generados
        return JSONResponse({
            "token_id": token_id_response["token"],
            "token_data": secret_response.response["data"]["token"]
        }, 200)
    
    except Exception as e:
        # Maneja cualquier error desconocido
        logger.error("Error Inesperado: %s", e)
        return JSONResponse({
            "info": "Error desconocido por el servidor",
            "status": "no",
            "type": "UNKNOWN_ERROR",
            "detail": str(e)
        }, 500)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/restricted/booking/main.py
from fastapi import (
    APIRouter,
    Request,
    HTTPException,
    status,
    Response
)
from fastapi.responses import JSONResponse
from datetime import datetime
from bson import ObjectId
from typing import Optional
from typing import Literal
from typing import Union
import numba as nb
from pydantic import BaseModel
from pydantic import validator
from pydantic import ValidationError
from crud.mongodb.booking.utils.serviceToPersonal import serviceToPersonal
from crud.mongodb.booking.utils.workerLessBusy import workerLessBusy
from crud.mongodb.booking.utils.conversorServices import conversorServices
from crud.mongodb.booking.add import AddBooking as MDBAddBooking
from crud.mongodb.booking.remove import RemoveBooking as MDBRemoveBooking
from crud.rethink_db.booking.add import AddBooking as RDBAddooking
from crud.rethink_db.booking.remove import RemoveBooking as RDBRemoveBooking
from crud.mongodb.booking.utils.remove.verifyDays import verifyDays
from Backend.microservices.app.API.v1.routes.client.schemes.general import schemes
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, configure, users, personal as db_personal
from Backend.microservices.app.API.v1.logging_config import logger
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt
from Backend.microservices.app.API.v1.crud.mongodb.booking.validate.count_appointments import CountAppointmentsModel, CountAppointments 

router = APIRouter(prefix="/booking")



class structure_test(BaseModel):
    day: int
    month: int
    year: int
    service: str

'''
Convertir el token en un simple id que pueda hacerse uso
'''

class structureRemove(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None
    id_reserva: str


@router.options('/remove')
async def Remove_Appointment_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post("/remove")
async def Remove_Appointment(request: Request, data: structureRemove):

    """
    Ruta para **quitar las reservas** de los **clientes**

    Errores exitentes:
    - DATABASE_ERROR
    - NOT_EXIST_BOOKING_ID
    - UNKNOW_ERROR
    - SERVICE_ERROR
    - VERIFY_DAYS_ERROR
    """


    try:
        #-> Responde de forma añadiendo el jwt integrado
        
        #@nb.jit(nopython=True)
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {"token": request.state.new_token}
            return JSONResponse(res, status)
        
        #-> Responde de forma añadiendo el jwt integrado


        #-> Obtiene el usuario del id, y la ficha de reserva de ese día
        try:
            user_id: str = request.state.user_id
            id_reserva: str = data.id_reserva
            user = users.find_one(
                { "_id": ObjectId(user_id) },
                {f"data.reservas.{id_reserva}": 1, "_id": 0}
            )
            user = user['data']['reservas']

            #print(f'data.reservas.{id_reserva}:', user)
        except Exception as e:
            return Response({
                "info": "Error en la base de datos, quizas no exista y tengas mal los mismos parametros",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)
        
        if id_reserva not in user:
            #print('->', id_reserva)
            #print('->', id_reserva not in user)
            #print('->', user)

            return Response({
                "info": "La id que pasaste no existe dentro del usuario",
                "status": "no",
                "type": "NOT_EXIST_BOOKING_ID"
            }, 401)
    
        reserva = user[id_reserva]
        #-> Obtiene el usuario del id, y la ficha de reserva de ese día


        #-> Parsea las variables para hacerlo úso en la ruta
        day_booked = reserva["date_appointment"].day
        month_booked = reserva["date_appointment"].month
        year_booked = reserva["date_appointment"].year
        period_booked = reserva["period"]
        start_time_booked = reserva["start_time"]
        responsable_appointment_booked = reserva["responsable_appointment"]
        service_booked = reserva["service"]

        #print(day_booked, month_booked, year_booked)
        #-> Parsea las variables para hacerlo úso en la ruta


        #-> Obtiene los servicios actuales para reservar
        services = conversorServices()
        logger.info("..............CONVERSOR SERVICES: %s", services)

        #print('services ->', services.response)

        if services is not None:
            if not services.response["status"] == 'ok':
                return Response(services.response, 401)
        else:
            return Response({
                "info": "Error al obtener los servicios.",
                "sub_response": services.response,
                "status": "no",
                "type": "SERVICE_ERROR"
            }, 401)

        services = services.response["data"]
        #-> Obtiene los servicios actuales

        
        #-> Verifica que si faltan 3 dias
        #'''/crud/booking/utils/remove/verify_days.py'''

        """verify_days = verifyDays(day_booked, month_booked, year_booked)
        
        if not verify_days.response["status"] == 'ok':
            return Response({
                "info": "Error al verificar los dias antes posibles al cancelar la reserva.",
                "sub_response": verify_days.response,
                "status": "no",
                "type": "VERIFY_DAYS_ERROR"
            }, 401)"""
        #print(verify_days.response)
        #-> Verifica que si faltan 3 dias
        

        

        #-> Quita de la parte del usuario la reserva
        '''/crud/booking/remove.py'''
        #print('------------')
        remove_booking = MDBRemoveBooking(
            MDBRemoveBooking.structure(
                day= day_booked,
                month= month_booked,
                year= year_booked,
                professional= responsable_appointment_booked,
                period= period_booked,
                start_time= start_time_booked,
                service_duration= services[service_booked][0],
                person_id= user_id,
                service_name= service_booked,
                id_appointment= id_reserva
            )
        )
        #-> Quita de la parte del usuario la reserva
        #print('------------')

        #-> Verifica si pudo quitar la reserva del usuario sin problemas
        if not remove_booking.response["status"] == "ok":
            return Response(remove_booking.response, 401)
        #-> Verifica si pudo quitar la reserva del usuario sin problemas
        #print('------------')
        #print('llego a eliminar la reserva correctamente')


        """logger.info("..........................................................")

        # Registrar el ID del usuario
        logger.info(f"user_id: {user_id}")

        # Registrar el ID de la reserva
        logger.info(f"id_reserva: {id_reserva}")

        # Registrar la reserva del usuario
        logger.info(f"user: {user}")

        # Registrar los detalles de la reserva
        logger.info(f"day_booked: {day_booked}")
        logger.info(f"month_booked: {month_booked}")
        logger.info(f"year_booked: {year_booked}")
        logger.info(f"period_booked: {period_booked}")
        logger.info(f"start_time_booked: {start_time_booked}")
        logger.info(f"responsable_appointment_booked: {responsable_appointment_booked}")
        logger.info(f"service_booked: {service_booked}")

        # Registrar los servicios obtenidos
        logger.info(f"services: {services}")

        # Registrar el resultado de la verificación de días
        logger.info(f"verify_days.response: {verify_days.response}")

        # Registrar el resultado de la eliminación de la reserva
        logger.info(f"remove_booking.response: {remove_booking.response}")

        # Registrar los datos de la reserva para RDB
        #logger.info(f"booking_data_rdb: {booking_data_rdb}")

        logger.info("..........................................................")"""

        type_personal: str

        if service_booked in services:
            type_personal = services[service_booked][2]
        
        booking_data_rdb: dict = {
            "date": datetime(year_booked, month_booked, day_booked),
            "personal_id": responsable_appointment_booked,
            "personal_type": type_personal,
            "appointment_id": id_reserva
        }
        booking_data_rdb_structure: RDBRemoveBooking.structure = RDBRemoveBooking.structure(**booking_data_rdb)
        result_booking_rdb = RDBRemoveBooking(booking_data_rdb_structure)

        if not result_booking_rdb.response["status"] == "ok":
            logger.error(f'{result_booking_rdb.response}')
            return Response(result_booking_rdb.response, 401)

        #-> Obtiene el resultado de forma éxitosa
        return Response({
            "info": "Se elimino la reserva correctamente",
            "status": "ok",
            "type": "SUCCESS",
            "data": remove_booking.response
        }, 200)
        #-> Obtiene el resultado de forma éxitosa

    except Exception as e:
        #print('bad2')
        return Response({
            "info": f"Error desconocdio del servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR"
        }, 500)


morning_time = Literal[
    '9:00',
    '9:30',
    '10:00',
    '10:30',
    '11:00',
    '11:30',
    '12:00',
    '12:30',
    '13:00',
    '13:30',  
        ]
afternoon_time = Literal[
            '15:00',
            '15:30',
            '16:00',
            '16:30',
            '17:00',
            '17:30',
            '18:00',
            '18:30',
            '19:00',
            '19:30',
        ]

class structureAdd(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None
    day_date: int
    month_date: int
    year_date: int
    hour: Union[
        morning_time,
        afternoon_time
    ]
    period: Literal['morning', 'afternoon']
    name_service: str


@router.options('/add')
async def Add_Appointment_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }

@router.post("/add")
async def Add_Appointment(request: Request, data: structureAdd):

    '''
    Ruta para **crear una reserva** del usuario
    
    Errores exitentes:
    - ERROR_DATABASE_DATE
    - UNKNOW_ERROR
    - SERVICE_ERROR
    '''

    try:
        day_date = data.day_date
        month_date = data.month_date
        year_date = data.year_date
        name_service = data.name_service
        hour = data.hour
        period = data.period
        user_id = request.state.user_id

        #@nb.jit(nopython=True)
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {"token": request.state.new_token}
            return JSONResponse(res, status)
        

        day = datetime(year_date, month_date, day_date)

        data_count_appointments = CountAppointmentsModel(user_id=user_id)
        count_appointments = CountAppointments()
        result_count_appointments = count_appointments(data_count_appointments)

        if not result_count_appointments["status"] == "ok":
            return Response(result_count_appointments, 401)
        
        try:
            
            #Verifica si existe existe la version del appointment_day y si esta vacia
            
            appointment = reservas.find_one({"fecha": {"$eq": day}})
            logger.info('APPOINTMENT ADD: ', day)
            version_appointment = appointment["version"]

            if not appointment:
                return Response({
                    "info": f"Hubo un error a al acceder esa ficha de reserva en ese día: {day}",
                    "status": "no",
                    "type": "ERROR_DATABASE_DATE"
                }, 401)
        except Exception as e:
            return Response({
                "info": f"Hubo un error a al acceder esa ficha de reserva en ese día: {day}",
                "status": "no",
                "type": "ERROR_DATABASE_DATE"
            
            }, 401)
        #print(version_appointment)
        
        #Arrays de varios tipos de profesion, y da el array de las personas que hay
        personal_raw = db_personal.find_one({ "version": version_appointment })
        #print(personal_raw)

        logger.info("APPOINTMENT: PASO 1")

        '''
        Verificar que el usuario solo tenga de reservas 2, si lo supera
        '''

        personal = serviceToPersonal(
            serviceToPersonal.service(
                service= name_service
            )
        )

        logger.info("APPOINTMENT: PASO 2")
        #print(personal.response)

        if personal.response["status"] == 'no':
            return Response(personal.response, 401)

        #Obitene de la ficha general el personal especifico para saber el horario que tiene, y ver su estado
        specific_personal = personal_raw["personal"][personal.response["data"]]

        #Retorna una lista, donde los trabajadores con menos trabajo salen en los primeros de la lista
        worker_less_bussy = workerLessBusy(
            workerLessBusy.structure(
                rama_profesionales=specific_personal,
                professionals=appointment
            )
        )

        logger.info("APPOINTMENT: PASO 3")

        if not worker_less_bussy.response["status"] == 'ok':
            return Response(worker_less_bussy.response, 401)
        
        #print('worker less bussy->', worker_less_bussy.response["data"])

        #Obtiene todos los servicios procesadora para hacerse uso
        services = conversorServices()

        logger.info("APPOINTMENT: PASO 4")

        #print('services ->', services.response)

        if services is not None:
            if not services.response["status"] == 'ok':
                return Response(services.response, 401)
        else:
            return Response({
                "info": "Error al obtener los servicios.",
                "status": "no",
                "type": "SERVICE_ERROR"
            }, 401)

        services = services.response["data"]
        

        #######################################################
        '''
        Luego de verificarse por JWT, en el middleware y puso bien su credenciales, pasa a hacer el booking
        aqui deberemos de acceder por por request.state, pluego validaremos o podriamos directamente validar
        con un parametro y especiifcar la estrtura con pydantic directamente

        Luego de sus datos y todas las funciones que estan operativas, comenzaria en hacerse el booking,
        claro aqui necesitariamos saber que servicio quiere, y que dia lo quiere hacer, luego con el usuario
        verificado pondiramos su propia credneciales y podriamos seguir.

        No tenemos que olvidar que aunque una respuesta este mal, debemos de devolverle otro token de renovación,
        y lo digo porque, cada vez que pasa por el middleware cambia la calve del usuario de jwt, y esto para verificar
        que lo hace bien todo el proceso
        '''
        
        booking = MDBAddBooking(
            MDBAddBooking.structure(
                day=day_date,
                month=month_date,
                year=year_date,
                professionals=worker_less_bussy.response["data"],
                period=period,
                start_time=hour,
                service_duration=services[name_service][0],
                person_id=user_id,
                service=name_service
            )
        )

        logger.info("APPOINTMENT: PASO 5")
        #print('aca', booking.response)

        logger.info(f"APPOINTMENT: {booking.response}")
        
        if not booking.response["status"] == 'ok':
            return Response(booking.response, 401)
        #######################################################

        #######################################################
        hour_obj = datetime.strptime(hour, "%H:%M")
        hour_12 = hour_obj.strftime("%I:%M %p")

        user_raw: dict = users.find_one({ "_id": ObjectId(user_id) })
        user_email: str = user_raw["data"]["info"]["email"]
        decrypted_user_email: str = decrypt(user_email)
        
        logger.info("APPOINTMENT: PASO 7")

        logger.info(".............................")

        logger.info(f"Hour en str: {hour_12}")
        logger.info(f"Usuario del personal: {worker_less_bussy.response["data"][0][0]}")
        logger.info(f"Id reserva: {booking.response["data"]["id_appointment"]}")
        logger.info(f"Fecha: {day}")
        logger.info(f"Tipo de personal: {personal.response["data"]}")
        logger.info(f"Usuario: {user_email}")

        logger.info(".............................")

        booking_data_rdb: dict = {
            "user": decrypted_user_email,
            "date": day,
            "hour": hour_12,
            "id_appointment": booking.response["data"]["id_appointment"],
            "personal_type": personal.response["data"],
            "personal_id": worker_less_bussy.response["data"][0][0]
        }


        booking_rdb = RDBAddooking(
            RDBAddooking.structure(**booking_data_rdb)
        )

        logger.info("APPOINTMENT: PASO 8")

        if not booking_rdb.response["status"] == "ok":
            logger.info(f'error -> {booking_rdb.response}')
            return Response(booking_rdb.response, 401)

        logger.info("APPOINTMENT: Acabo 🧘")

        return Response(booking.response, 200)
        #######################################################
        

    except Exception as e:
        logger.error(f"ERROR APPOINTMENT: {e}")
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/restricted/data/main.py
from fastapi import APIRouter, Request, Response
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from datetime import datetime
from bson import ObjectId
from typing import Optional
from config.config import conf
from datetime import datetime
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, configure, users, personal as db_personal
from Backend.microservices.app.API.v1.logging_config import logger

router = APIRouter(prefix="/data")

from datetime import datetime
import numba as nb

class middleware_struct(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None


'''
Porque no se usa el parametro data en las rutas?

- Simplemente es para que se pueda ver las variables a usar en la documentación

'''


@router.options('/appointments')
async def Data_Appointments_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post('/appointments')
async def Data_Appointments(request: Request, data: middleware_struct) -> JSONResponse:

    '''
    Enseña las reservas que hizo el **usuario**

    Errores exitentes:
    - DATABASE_ERROR
    - USER_NOT_FOUND
    - UNKNOW_ERROR
    - VERIFY_NOT_TRUE
    '''
    def code() -> dict:

        try:
            user_id = str(request.state.user_id)
            logger.info(f"(/appointments) USER ID: {user_id}")
            appointments = users.find_one({ "_id": ObjectId(user_id) }, {'_id': 0, 'reservas': 1})
            #print('appointments ->', appointments)

        except Exception as e:
            logger.info(f"(/appointments) ERROR: {user_id}")
            return Response({
                "info": "Hubo un error a la base de datos",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)
        
        if not appointments:
            return Response({
                "info": "El usuario no tiene reservas listadas",
                "status": "ok",
                "type": "USER_WITHOUT_APPOINTMENTS"
            }, 200)

        # Convertir objetos datetime a cadenas de texto
        for _, reservas in appointments['reservas'].items():
            #print('reservas---->', reservas)
            reservas["date_appointment"] = str(reservas["date_appointment"])

        return Response({
            "info": "Se obtuvo del usuario sus reservas",
            "status": "ok",
            "type": "SUCCESS",
            "data": appointments
        }, 200)



    try:
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {
                "token": request.state.new_token
            }
            return JSONResponse(res, status)
        
        return code()
        
        

    except Exception as e:
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)


@router.options('/services')
async def Data_Services_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post("/services")
async def Data_Services(request: Request, data: middleware_struct) -> JSONResponse:

    '''
    Enseña **todos** los **servicios disponibles** dentro de la base de datos

    Errores exitentes:
    - DATABASE_ERROR
    - UNKNOW_ERROR
    '''

    try:

        #@nb.jit(nopython=True)
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {"token": request.state.new_token}
            return JSONResponse(res, status)
        try:
            #print('config db->', conf["db"]["services"])
            services = configure.find_one({ "_id": ObjectId(conf["db"]["services"]) })

        except Exception as e:
            return Response({
                "info": "Error al obtener los servicios de la base de datos",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 500)
        
        if not services:
            return Response({
                "info": "No se encuentra ningún documento sobre los servicios",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 500)

        services.pop('_id', None)

        return Response({
            "info": "Entrega de los servicios de forma correcta",
            "status": "ok",
            "type": "SUCCESS",
            "data": services
        }, 200)

    except Exception as e:
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)
    


class structureBookingDaySheet(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None
    day: int
    month: int
    year: int


@router.options('/booking_day_sheet')
async def Data_Booking_Day_Sheet_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post('/booking_day_sheet')
async def Data_Booking_Day_Sheet(request: Request, data: structureBookingDaySheet) -> JSONResponse:

    '''
    Enseña la **ficha** del usuario

    Errores exitentes:
    - DATABASE_ERROR
    - USER_NOT_FOUND
    - UNKNOW_ERROR
    '''
    def code() -> dict:

        try:
            day = data.day
            month = data.month
            year = data.year

            date_of_the_sheet = datetime(year, month, day)
            appointment_sheet = reservas.find_one({ "fecha": {"$eq": date_of_the_sheet} }, {'_id': 0, 'professionals': 1})
            #print('appointments ->', appointment_sheet)

        except Exception as e:
            return Response({
                "info": f"Hubo un error a la base de datos: {e}",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)
        
        if not appointment_sheet:
            return Response({
                "info": "No se encontro el usuario, o esta en el db vació",
                "status": "no",
                "type": "USER_NOT_FOUND"
            }, 200)


        return Response({
            "info": "Se obtuvo del usuario sus reservas",
            "status": "ok",
            "type": "SUCCESS",
            "data": appointment_sheet
        }, 200)



    try:
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {
                "token": request.state.new_token
            }
            return JSONResponse(res, status)
        
        return code()
    
    except Exception as e:
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/restricted/user/config/main.py
from fastapi import APIRouter, Request, Response
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from datetime import datetime
from bson import ObjectId
from typing import Optional
from config.config import conf
from datetime import datetime
import numba as nb
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, configure, users, personal as db_personal
from Backend.microservices.app.API.v1.shared_microservices.cryptoapi.main import encrypt, decrypt

router = APIRouter(prefix="/config")


'''
Porque no se usa el parametro data en las rutas?

- Simplemente es para que se pueda ver las variables a usar en la documentación

'''


class structureResetPassword(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None
    current_psw: str
    new_psw: str

@router.options('/reset_password')
async def Config_Reset_Password_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }

@router.post('/reset_password')
async def Config_Reset_Password(request: Request, data: structureResetPassword) -> JSONResponse:

    '''
    La ruta **cambia** la contraseña actual **por la nueva** del usuario
    '''
    def code() -> dict:

        current_psw: str = str(data.current_psw)
        encrypted_current_psw: str = encrypt(current_psw)
        new_psw: str = str(data.new_psw)
        encrypted_new_psw: str = encrypt(new_psw)

        try:
            #print('--------------------')
            user_id = str(request.state.user_id)

            #Obtiene la contraseña sin ser procesado
            current_psw_db_raw = users.find_one({ "_id": ObjectId(user_id) }, {'_id': 0, 'data.info.password': 1})
            
            #Obtiene la contraseña procesado
            current_psw_db = current_psw_db_raw["data"]["info"]["password"]
            #print('appointments ->', current_psw)

        except Exception as e:
            return Response({
                "info": "Hubo un error a la base de datos",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)
        
        if not current_psw_db:
            return Response({
                "info": "No se encontro el usuario, o esta en el db vació",
                "status": "no",
                "type": "USER_NOT_FOUND"
            }, 401)
        
        #print('current_psw ->', current_psw)
        #print('new_psw ->', new_psw)
        #print('current_psw_db ->', current_psw_db)
        

        
        # Valida si la contraseña puesta "actual" es el mismo que la contraseña actual en el db
        if not current_psw_db == encrypted_current_psw:

            #print('No cuadra la contraseña con el db')
            return Response({
                "info": "La contraseña no cuadra con la actual",
                "status": "no",
                "type": "PASSWORD_DONT_MATCH"
            }, 401)
        
        #print('--------------------')
        
        #Cambia la contraseña si todo fué bien
        try:
            users.update_one(
                {"_id": ObjectId(user_id)},
                { "$set": {
                        "data.info.password": encrypted_new_psw
                    }
                }
            )
        except Exception as e:
            return Response({
                "info": "Hubo un error a la base de datos",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)

        return Response({
            "info": "Se cambio la contraseña actual por la nueva contraseña",
            "status": "ok",
            "type": "SUCCESS",
            "data": encrypted_new_psw
        }, 200)



    try:
        def Response(res: dict, status: int) -> JSONResponse:
            res["renew"] = {
                "token": request.state.new_token
            }
            return JSONResponse(res, status)
        
        return code()
        
        

    except Exception as e:
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/restricted/user/main.py
from fastapi import APIRouter, Request, Response
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from Backend.microservices.app.API.v1.db.mongodb.database import reservas, configure, users, personal as db_personal
from datetime import datetime
from bson import ObjectId
from typing import Optional
from config.config import conf
from crud.mongodb.users.delete import UserDelete

'''
En esta ruta solamnete es operaciónes internas del usaurio y no cambios en si.
Como por ejemplo eliminar la cuenta, operaciónes englobadas con el usuario, no en cambios de configruación
'''

from .config.main import router as router_config
router = APIRouter(prefix="/user")

router.include_router(router_config)

from datetime import datetime
import numba as nb

class middleware_struct(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None


'''
Porque no se usa el parametro data en las rutas?

- Simplemente es para que se pueda ver las variables a usar en la documentación

'''

class structureDelete(BaseModel):
    token_id: Optional[str] = None
    token_data: Optional[str] = None
    verify: bool


@router.options('/delete')
async def User_Delete_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }


@router.post('/delete')
async def User_Delete(request: Request, data: structureDelete) -> JSONResponse:

    '''
    Ruta para **eliminar** la cuenta del **usuario existente**


    Errores exitentes:
    - DATABASE_ERROR
    - USER_NOT_FOUND
    - UNKNOW_ERROR
    - APPOINTMENTS_EXISTENTS
    '''
    def code() -> dict:
        
        verify = data.verify
        print(request.state.new_token)

        # Si la eliminación de la cuenta no esta verificada, no se puede eliminar. Puede ser que manera no intencionada
        if not verify:
            return {
                "info": "No quiso eliminar la cuenta de forma intenconada",
                "status": "no",
                "type": "VERIFY_NOT_TRUE"
            }

        try:
            user_id = str(request.state.user_id)
            user = users.find_one({ "_id": ObjectId(user_id) }, { '_id': 0 })

        except Exception as e:
            return Response({
                "info": "Hubo un error a la base de datos",
                "status": "no",
                "type": "DATABASE_ERROR"
            }, 401)
        
        #Elimina la cuenta del usuario
        delete_user = UserDelete(
            UserDelete.structure(
                user_id=user_id
            )
        )
        
        #print('Delete User->', delete_user.response)
        if not delete_user.response["status"] == 'ok':
            return Response(delete_user.response, 401)

        #print('sus ->', print)
        return Response({
            "info": "Se obtuvo del usuario sus reservas",
            "status": "ok",
            "type": "SUCCESS"
        }, 200)


    try:
        def Response(res: dict, status: int) -> JSONResponse:
            #print('>>>>>>>>>>>>>>>>>> req state', request.state.__dict__)
            res["renew"] = {
                "token": request.state.new_token
            }
            return JSONResponse(res, status)
        
        return code()
        
        

    except Exception as e:
        return JSONResponse({
            "info": f"Error desconocido por el servidor: {e}",
            "status": "no",
            "type": "UNKNOW_ERROR",
            "renew": {
                "token": request.state.new_token
            }
        }, 500)


/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/restricted/main.py

from fastapi import (
    APIRouter,
    Request,
    HTTPException,
    status
)
from fastapi.responses import JSONResponse
from routes.client.restricted.booking.main import router as router_booking
from routes.client.restricted.data.main import router as router_data
from routes.client.restricted.user.main import router as router_user
from pydantic import BaseModel

router = APIRouter(prefix="/restricted")

router.include_router(router_data)
router.include_router(router_booking)
router.include_router(router_user)

'''
@router.post('/status')
async def root(request: Request):


    data: dict = {
        "email": request.state.email,
        "password": request.state.password,
        "renew": {
            "token": request.state.new_token
        }
    }

    try:
        return {
            "email": request.state.email,
            "password": request.state.password,
            "renew": {
                "token": request.state.new_token
            }
        }
    except AttributeError as e:
        return JSONResponse({
            "info": str(e),
            "status": "no",
            "type": "ATTRIBUTE_ERROR",
            "details": "Revisar la estructura y los datos añadidos"
        }, 401)
    except Exception as e:
        return JSONResponse({
            "info": str(e),
            "status": "no",
            "type": "ATTRIBUTE_ERROR"
        }, 401)
'''
Backend/microservices/app/API/v1/routes/client/schemes/general.py
from pydantic import BaseModel, EmailStr
#from pydantic import EmailStr

class schemes:
    #Login & Register
    class Credentials(BaseModel):
        email: EmailStr
        password: str

    #Login
    class Token(BaseModel):
        token: str

    #Register
    class NewUser(BaseModel):
        user: str
        psw: str
        email: str
    
    class TokenCredentials(BaseModel):
        token_id: str
        token_data: str

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/routes/client/main.py
from fastapi import APIRouter, Response
from fastapi.responses import JSONResponse
from routes.client.restricted.main import router as router_restricted
from routes.client.public.main import router as router_public

router = APIRouter()
router.include_router(router_restricted)
router.include_router(router_public)


@router.options('/status')
async def Status_Options(response: Response):

    response.headers["Allow"] = "POST, OPTIONS"
    response.headers["Content-Type"] = "application/json"
    return {
        "options": ["POST", "OPTIONS"]
    }

@router.get('/status')
async def Status():
    """AI is creating summary for Status

    Returns:
        [type]: [description]
    """
    try:
        return JSONResponse({
            "schemaVersion": 1,
            "label": "status",
            "message": "ok",
            "color": "green"
        }, 200)
    except Exception:
        return JSONResponse({
            "schemaVersion": 1,
            "label": "status",
            "message": "ok",
            "color": "green"
        }, 200)

/home/adrian/Documentos/PeluqueriaMael/Backend/microservices/app/API/v1/shared_microservices/cryptoapi/main.py
import httpx
from pydantic import BaseModel, ValidationError, field_validator
from validate_utf8 import find_utf8_errors
import re
from typing import Union
from Backend.microservices.conversor.config.config import Config
from Backend.microservices.app.API.v1.logging_config import logger

# Configuración
config: dict = Config()
app: str = config['app']

host: str = app['CryptoAPI']['host']
port: str = app['CryptoAPI']['net']['port']
ssl: str = app['CryptoAPI']['ssl']
protocol: str = 'https' if ssl else 'http'
BASE_URL: str = f"{protocol}://{host}:{port}"

# Expresiones regulares para validación
patron_binario = re.compile(b'^[\x20-\x7E]+$')  # Permite solo caracteres imprimibles ASCII
patron_texto = re.compile(r'^[a-zA-Z0-9\s.,!?@\'"_-]+$')  # Permite solo caracteres permitidos

class DecryptBytes(BaseModel):
    encrypted: bytes


class EncryptText(BaseModel):
    text: str

    @field_validator('text')
    @classmethod
    def check_valid_utf8(cls, value: str) -> Union[str, ValueError]:
        # Verificar UTF-8
        errors = find_utf8_errors(value.encode('utf-8'))
        if errors:
            raise ValueError(f'El texto contiene caracteres que no están codificados en UTF-8: {errors}')
        
        # Convertir a bytes para validar caracteres permitidos
        texto_bytes = value.encode('utf-8')
        if not patron_binario.fullmatch(texto_bytes):
            raise ValueError('El texto contiene caracteres no imprimibles en ASCII.')

        """ # Verificar caracteres permitidos en texto
        if not patron_texto.fullmatch(value):
            logger.info(f"VALUE ERROR: {value}")
            raise ValueError('El texto contiene caracteres especiales no permitidos.')
        """
        return value

def encrypt(text: str) -> Union[str, Exception, ValueError]:
    """Encriptar texto usando una API.

    Args:
        text (str): El texto a encriptar.

    Raises:
        Exception: Si ocurre un error durante la encriptación.

    Returns:
        bytes: Texto encriptado.
    """
    try:
        valid_text = EncryptText(text=text)
    except ValidationError as e:
        raise ValueError(f"Error de validación: {e}")
    
    with httpx.Client() as client:
        to_encrypt: bytes = valid_text.text.encode("utf-8")
        print(f"{BASE_URL}/cryptoapi/app/api/v1/gpu/encrypt")
        result = client.post(f"{BASE_URL}/cryptoapi/app/api/v1/gpu/encrypt", content=to_encrypt, headers={"Content-Type": "application/octet-stream"})
        content: bytes = result.content
        #print(content, '<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')

        if content == b'0' or result.status_code != 200:
            raise Exception("Hubo un error a la hora de encriptar")
        
        if not result.content.decode("ascii"):
            raise ValueError("Los bytes no son formateados con letras ascii")

        return (result.content).decode()

def decrypt(encrypted: str) -> Union[str, Exception]:
    """Desencriptar texto usando una API.

    Args:
        encrypted (bytes): Texto encriptado.

    Raises:
        Exception: Si ocurre un error durante la desencriptación.

    Returns:
        bytes: Texto desencriptado.
    """

    encrypted: bytes = encrypted.encode()
    with httpx.Client() as client:
        result = client.post(f"{BASE_URL}/cryptoapi/app/api/v1/gpu/decrypt", content=encrypted, headers={"Content-Type": "application/octet-stream"})
        content: bytes = result.content

        if content == b'0' or result.status_code != 200:
            raise Exception("Hubo un error a la hora de encriptar o desencriptar")

        return content.decode()

if __name__ == "__main__":
    import time

    text = "sadsadsadsasa"  # Usa una cadena válida para probar
    start_time = time.time()

    for i in range(1000):
        encrypted_text = encrypt(text + str(i))
        #print(f'Encrypted text: {encrypted_text}')

        decrypted_text = decrypt(encrypted_text)
        #print(f'Decrypted text: {decrypted_text.decode("utf-8")}')

    end_time = time.time()
    print(f'Execution time: {end_time - start_time}')

Backend/microservices/app/API/v1/server_fastapi.py
from fastapi import FastAPI, APIRouter, Request
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi_cache import FastAPICache
from fastapi.middleware.gzip import GZipMiddleware
from fastapi_cache.backends.redis import RedisBackend
from routes.admin.admin import router as admin_router
from routes.client.main import router as client_router
from routes.worker.worker import router as worker_router
from config.middlewares.client.restricted import RestrictedMiddleware
from config.middlewares.client.handleError import ErrorMiddleware
import ujson
import os
import fastapi
from redis import asyncio as aioredis
from Backend.microservices.conversor.config.config import Config
from Backend.microservices.app.API.v1.logging_config import logger
from Backend.microservices.app.API.v1.db.redis_db.database import RedisClient, setup_redis_limiters_and_cache, rate_limit

# Initialize configuration and application settings
config = Config()
host = config['host']
ssl_cert = config['ssl']['cert']
ssl_key = config['ssl']['key']
app_config = config['app']
ssl = app_config['API']['ssl']
cache = app_config['API']['cache']
cors = app_config["API"]["cors"]
gzip = app_config["API"]["gzip"]
port = app_config['API']['net']['port']

# Initialize FastAPI application
app = FastAPI()

# Environment configuration: "prod" for Production or "dev" for Development
environment = "dev"

def setup_cache_and_redis():
    """
    Configures Redis for rate limiting and caching if enabled in the configuration.
    """
    if cache:
        setup_redis_limiters_and_cache(app)
        logger.info(f"API connected with Redis cache. {RedisClient.REDIS_URL}")
    else:
        logger.error(f"Failed to connect API with Redis cache. {RedisClient.REDIS_URL}")

def setup_routes():
    """
    Sets up the routes and includes specific routers for the application.
    """
    base_router = APIRouter()
    base_router.include_router(admin_router, prefix="/admin", tags=["admin"])
    base_router.include_router(client_router, prefix="/client", tags=["client"])
    base_router.include_router(worker_router, prefix="/worker", tags=["worker"])
    app.include_router(base_router, prefix="/api/app/api/v1")

def setup_middlewares():
    """
    Configures middlewares for the FastAPI application including custom middlewares,
    GZip, and CORS.
    """
    app.add_middleware(ErrorMiddleware)
    app.add_middleware(RestrictedMiddleware)

    if gzip['enabled']:
        app.add_middleware(GZipMiddleware, minimum_size=gzip['min_size'])

    if cors['enabled']:
        app.add_middleware(
            CORSMiddleware,
            allow_origins=cors["origins"],
            allow_credentials=True,
            allow_methods=cors["methods"],
            allow_headers=cors["headers"],
        )

def setup_events():
    """
    Defines startup and shutdown events for the FastAPI application.
    """
    @app.on_event("startup")
    async def startup_event():
        pass

    @app.on_event("shutdown")
    async def shutdown_event():
        await RedisClient.disconnect()

def setup_routes_with_limiters():
    """
    Sets up routes with rate limiting.
    """
    @app.get("/error")
    @rate_limit("1/second")
    async def trigger_error(request: Request):
        """
        Triggers an error to test rate limiting.
        """
        raise ValueError("This is an Error")

    @app.get("/hidden_egg")
    @rate_limit("1/second")
    def hidden_egg(request: Request) -> HTMLResponse:
        """
        Returns an HTML response with a hidden egg image.
        """
        return HTMLResponse(
            content="""
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Hidden egg</title>
            </head>
            <body>
                <img src="https://images.pexels.com/photos/3343/easter-eggs.jpg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=0">
            </body>
            </html>
            """,
            status_code=200
        )

def run_server():
    """
    Runs the FastAPI application using Uvicorn with specified configuration.
    """
    import uvicorn

    if ssl:
        uvicorn.run(
            "server_fastapi:app",
            host=host,
            port=port,
            reload=True,
            workers=2,
            ssl_certfile=ssl_cert,
            ssl_keyfile=ssl_key,
            proxy_headers=True,
            forwarded_allow_ips="*"
        )
    else:
        uvicorn.run(
            "server_fastapi:app",
            host=host,
            port=port,
            reload=True,
            workers=2,
            proxy_headers=True,
            forwarded_allow_ips="*"
        )

# Setup application
setup_cache_and_redis()
setup_routes()
setup_middlewares()
setup_events()
setup_routes_with_limiters()

# Run the server if the script is executed directly
if __name__ == "__main__":
    run_server()

Backend/microservices/app/API/v1/pytest.ini
[pytest]
addopts = -v --disable-warnings -s

# Controla el nivel de advertencias
filterwarnings =
    ignore::DeprecationWarning

# Path
testpaths = 
    __tests__